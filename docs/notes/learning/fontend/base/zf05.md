# 珠峰前端全栈培训第五周：dom零级、二级事件基础和实战

[TOC]

----------

## 课时104：什么是事件

- 什么是事件?
  1. 行为本身：浏览器天生就赋予其的行为，例如`onclick`, `onmouseover(onmouseenter)`, `onmouseout(onmouseleave)`, `onmousemove`, `onmousedown`, `onmouseup`, `onmousewheel`(鼠标滚轮滚动行为), `onscroll`
  2. 事件绑定：给元素的某一个行为绑定方法
 

```javascript
var oDiv = document.getElementById("#box");

// onclick这个行为定义在当前元素的私有属性上
// 我们称之为DOM 0级事件绑定
oDiv.onclick = function handler () { ... };

// addEventListener这个属性则定义在"EventTarget"这个接口上，放在该元素的原型链上
// 我们称之为DOM 2级事件绑定
oDiv.addEventListener("click", handler);
```

- 关于为什么没有DOM 1级事件： 很久以前，DOM刚开发时，版本为0级，后来又进行了一次升级升级到1级，但这次升级并没有更新DOM事件，后来再次升级到DOM 2级时，DOM事件得到了更新就有了DOM2级事件绑定。


----------

## 课时105：事件对象及兼容处理

```javascript
// 表示我们把匿名函数定义的部分当做一个值赋值给了oDiv的点击行为(函数表达式)
oDiv.onclick = function (mouseEvent) { ... }
// 当我们触发#div的点击行为时，会执行对应绑定上的方法
// ★重要：不仅仅把绑定的方法执行了，而且浏览器还默认的给这个方法传递了一个参数 --> MouseEvent：鼠标事件对象
//   1. 它是一个对象数据类型值，里面包含了很多属性名和属性值，这些都是用来记录当前鼠标的相关信息
//   2. MouseEvent的原型链：MouseEvent -> UIEvent -> Event -> Object
//   3. MouseEvent记录的是页面中唯一一个鼠标每次触发时的相关信息，和到底是在哪个元素上触发的没关系
```

**关于事件对象MouseEvent的兼容问题**
```javascript
oDiv.onclick = function (e) {
  // 在非标准浏览器(IE6~8)中，我们需要去window.event上获取。
  e = e || window.event;
  e.target = e.target || e.srcElement
  e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft)
  e.pageY = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop)
  e.preventDefault ? e.preventDefault() : e.returnValue=false
  // 阻止默认行为可以直接用return false！
  // 更可以在html事件代码中直接加"javascript:;"或者"javascript: void 0;"或者"javascript: viod 1;"
  
  // e.stopPropagation 阻止事件的冒泡传播，在IE6~8中不兼容，使用e.cancelBubble=true兼容处理
  e.stopPropagation ? e.stopPropagation() : e.cancelBubble=true
}
  // e.type：当前鼠标触发的行为类型 “click” ...
  // e.clientX/e.clientY：当前鼠标触发点所距离当前浏览器屏幕(viewport,视口)左上角的x轴和y轴的坐标值
  // e.target：事件源，当前鼠标触发的是哪个元素
  // e.pageX/e.pageY：当前鼠标触发点所距离body左上角的x/y轴的坐标，但问题是在IE6~8下不兼容，处理办法为使用clientX/Y+滚动条卷曲的高度或宽度即可
  // e.preventDefault: 阻止浏览器的默认行为，但问题是IE6~8中不兼容，使用e.returnValue=false解决兼容问题
  
  // KeyboardEvent 键盘事件对象
  // e.keyCode：当前键盘上每一个键对应的值
  // 空格键(space)->32 , 退回键(Backspace)->8 , 回车键(Enter)->13 , 删除键(Del)->46
```

----------

## 课时106：事件的传播机制

- 事件的默认传播机制：
  - 捕获阶段：从外向内依次查找元素
  - 目标阶段：当前事件源本身的操作
  - 冒泡阶段：从内到外依次触发相关的行为
  
- 使用DOM-0级事件给元素的某一个行为绑定的方法，都是在行为触发后的冒泡阶段才去执行方法

- 因为由捕获阶段或冒泡阶段或目标阶段触发是的事件对象全都是相等的


----------

## 课时107：案例之鼠标跟随(jQuery版)

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson107</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            position: relative;
            width: 598px; /*图片140*4=560 左右边框2*4 margin-right:10*3 = 598 + 最后一个无用的margin-right=608 */
            height: 98px; /*上下边框2 图片75 margin-top:10 margin-bottom:10 = 98*/
            margin: 50px auto;
            border: 1px dashed darkgray;
        }

        .box .content {
            position: absolute;
            /*width: 100%;*/ /*千万别设100%，自适应，弟弟可以超过哥哥*/
            /*height: 100%;*/
            margin-right: -20px; /*哇哈哈~负边距应用了，成功放大了content元素！*/
            overflow: hidden;
        }

        .box img { /* 140*75 */
            float: left;
            margin: 10px 10px 10px 0;
            border: 1px solid red;
        }

        .mask {
            display: none;
            position: absolute;
            left: 0;
            top: 0;
            width: 522px; /*原始图片为520*280，但我上下和左右分别加了边框，所以各加2*/
            height: 282px;
            border: 1px solid lightgray;
            background: no-repeat center center;
        }
    </style>
</head>
<body>
<div id="box" class="box">
    <div id="content" class="content">
        <img src="./imgs/i01s.jpg" bigsrc="./imgs/i01.jpg" alt="1">
        <img src="./imgs/i02s.jpg" bigsrc="./imgs/i02.jpg" alt="2">
        <img src="./imgs/i03s.jpg" bigsrc="./imgs/i03.jpg" alt="3">
        <img src="./imgs/i04s.jpg" bigsrc="./imgs/i04.jpg" alt="4">
    </div>
    <div class="mask" id="mask"></div>
</div>
<script src="../jquery-1.12.4.js" type="text/javascript"></script>
<script type="text/javascript">
  $(function () {
    var boxOffet = $('#box').offset(),
        $imgs = $('img'),
        $mask = $('#mask');

    $imgs.mouseenter(function (e) {
      $mask
        .css("background-image", 'url("' + this.getAttribute("bigsrc") + '")')
        .finish()
        .fadeIn(400)
        .css({ //这里不能拿img的offset设置啊，因为mask是根据box定位，所以拿box的offset绝对距离即可！
          left: e.clientX - boxOffet.left + 10,
          top: e.clientY - boxOffet.top + 10
        });
    });

    $imgs.mouseleave(function (e) {
      $mask
        .finish()
        .fadeOut(200);
    });

    $imgs.mousemove(function (e) {
      $mask
        .css({
          left: e.clientX - boxOffet.left + 10,
          top: e.clientY - boxOffet.top + 10
        });
    });
  })
</script>
</body>
</html>
```

> 自己坑自己啊，写项目时头脑要清晰！昨晚儿子搞事情，05点才睡着，也是没法😣
  当然也玩了个负边距“放大”布局!!好玩!!

- 项目里mask是根据box定位的，所以在计算其top和left时，因用`e.clientX - box.offset().left + 10px`，而不能是`e.clientX - $(this).offset().left + 10`。

![zf-lesson107.png-35.4kB][1]

----------

## 课时108：案例之鼠标跟随(原生js版)

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson108_VanillaJS</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .container {
            position: relative;
            height: 402px;
            width: 402px;
            margin: 100px auto;
            border: 2px dashed red;
            background: lightgray;
        }

        .container .box {
            display: none;
            position: absolute;
            background: green;
            height: 100px;
            width: 100px;
            top: 410px;
            left: 410px;
        }
    </style>
</head>
<body>
<!--挖坑第一步：故意把box放在容器里，增加难度，为了理解时间的传播机制。-->
<div id="container" class="container">
    <div class="box" id="box"></div>
</div>
<script type="text/javascript">
  var cta = document.getElementById("container"),
    box = document.getElementById("box");
  //挖坑第二步，使用mouseover和mouseout事件触发行为
  //    cta.addEventListener('mouseover', function (e) {
  //      e = e || window.event;
  //      e.target = e.target || e.srcElement;
  //      box.style.display = 'block';
  //      box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //      box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //    }, false);
  //
  //    cta.addEventListener('mousemove', function (e) {
  //      e = e || window.event;
  //      e.target = e.target || e.srcElement;
  //      box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //      box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //    }, false);
  //
  //    cta.addEventListener('mouseout', function () {
  //      box.style.display = 'none';
  //    }, false);
  
  // 为什么我没遇到周老师讲的坑呢，奇怪啊，各种办法都试了。
  // 我明白了，原来他用的是事件函数里用的是"this"，如果那就复杂了。
  // 如果你this是container还好，如果是box那就冒泡了。
  //  cta.onmouseover = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.display = 'block';
  //    box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmousemove = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.left = e.clientX - cta.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - cta.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmouseout = function (e) {
  //    box.style.display = 'none';
  //  }
  
  // 我承认，我试了三遍，硬是没把坑试出来，是不是我基础太好了啊~~
  //  cta.onmouseover = function (e) {
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.display = 'block';
  //    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  //  };// 这尼玛永远也是container啊，不会出来周老师的坑嘛，哎，找个坑跳也那么麻烦，罢了。
  //
  //  cta.onmousemove = function (e) {
  //    console.dir(this);
  //    e = e || window.event;
  //    e.target = e.target || e.srcElement;
  //    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
  //    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  //  };
  //
  //  cta.onmouseout = function (e) {
  //    box.style.display = 'none';
  //  }
  
  // 第四遍，使用mouseenter和mouseleave代替，应为这两货在MDN文档中严重标明不支持冒泡机制！欧耶~
  cta.onmouseover = function (e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    box.style.display = 'block';
    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  };// 这尼玛永远也是container啊，不会出来周老师的坑嘛，哎，找个坑跳也那么麻烦，罢了。
  
  cta.onmousemove = function (e) {
    console.dir(this);
    e = e || window.event;
    e.target = e.target || e.srcElement;
    box.style.left = e.clientX - this.offsetLeft + 6 + 'px';
    box.style.top = e.clientY - this.offsetTop + 10 + 'px';
  };
  
  cta.onmouseout = function (e) {
    box.style.display = 'none';
  }
</script>
</body>
</html>
```

> 我输了，试了四遍，硬是没找到坑跳进去啊😂

- `mouseenter`和`mouseover` 、`mouseleave`和`mouseout`的本质区别：`mouseenter`和`mouseleave`这两个事件都是阻止事件冒泡，而`mouseover`和`mouseout`则不阻止事件冒泡。阻止行为冒泡传播的好处在于当触发子元素的某个行为时，导致父元素的该行为也被触发。

----------

## 课时109：鼠标跟随 深入理解事件的传播机制

```javascript
<script type="text/javascript">
  var box = document.getElementById("box"),
    inner = document.getElementById("inner");

  //    box.onmouseover = function () {
  //      inner.style.display = "block";
  //    };
  //
  //    box.onmouseout = function () {
  //      inner.style.display = "none";
  //    };

  // 升级绑定行为，取消事件的冒泡传递！
  box.onmouseenter = function () {
    inner.style.display = "block";
  }

  box.onmouseleave = function () {
    inner.style.display = "none";
  }
</script>
```

> 使用地球最快的Vanilla.js框架实现lesson107效果

```javascript
<script type="text/javascript">
  var cta = document.getElementById('container'),
    box = document.getElementById('box'),
    mask = document.getElementById('mask'),
    imgList = box.getElementsByTagName('img');
  // box距离body的距离，中间包了个container，手工算吧。
  // 算了都是根据container定位，不许算两道了，没意思。
  var ctaOffsetLeft = cta.offsetLeft,
    ctaOffsetTop = cta.offsetTop;

  function handleMouseEnter(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    mask.style.backgroundImage = 'url("' + this.getAttribute("bigsrc") + '")';
    mask.style.display = 'block';
    mask.style.left = e.clientX - ctaOffsetLeft + 10 + 'px';
    mask.style.top = e.clientY - ctaOffsetTop + 10 + 'px';
  }

  function handleMousemove(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    mask.style.left = e.clientX - ctaOffsetLeft + 10 + 'px';
    mask.style.top = e.clientY - ctaOffsetTop + 10 + 'px';
  }

  function handleMouseLeave() {
    mask.style.display = 'none';
  }

  for (var i = 0, len = imgList.length; i < len; i++) {
    // 其实这里可以用捕获来优化，直接绑定在box上即可，第二版本再优化。
    imgList[i].addEventListener('mouseenter', handleMouseEnter, false);
    imgList[i].addEventListener('mousemove', handleMousemove, false);
    imgList[i].addEventListener('mouseleave', handleMouseLeave, false);
  }
</script>
```

----------

## 课时110：事件委托 事件代理

- 什么叫事件委托/事件代理？利用事件的冒泡传播机制（触发当前元素的某项行为，它爸爸爷爷祖宗十八代元素的相关行为都会被触发）；如果一个容器里有很多元素都要绑定点击事件，我们没必要每一个都逐一绑定，只需给最外层的的容器绑定一个点击事件即可，在这个方法执行时，通过事件源来区分进行不同操作。

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson110</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .container {
            position: relative;
            height: 33px;
            width: 100px;
            border: 1px solid #000000;
            margin: 50px auto;
        }

        .container .cart {
            /*position: absolute; 不必定位，定位了还不好居中*/
            height: 33px;
            line-height: 30px;
            text-align: center;
            background: lightblue;
        }

        .container .cartDetail {
            position: absolute;
            top: 33px;
            left: -1px;
            height: 200px;
            width: 200px;
            background: lightgray;
            border: 1px solid #000000;
            text-align: center;
            line-height: 66px;
        }
    </style>
</head>
<body>
<div id="container" class="container">
    <div class="cart" id="cart">
        <span>购物车</span>
        <div class="cartDetail" id="cartDetail" style="display: none">
            1. iPhone7<br/>
            2. Mi6<br/>
            3. P10<br/>
        </div>
    </div>
</div>

<script type="text/javascript">
  var ctnr = document.getElementById("container"),
    cart = document.getElementById("cart"),
    cartDetail = document.getElementById("cartDetail");

  function handleCartClick(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    if (e.target.id === 'cart' || (e.target.tagName.toLocaleLowerCase() === 'span' && e.target.parentNode === cart)) {
      var dsp = cartDetail.style.display;
      dsp === 'none' ? cartDetail.style.display = 'block' : cartDetail.style.display = 'none';
      return false;
    }
    if (e.target.id === 'cartDetail') {
      return false;
    }
    cartDetail.style.display = 'none';
  }
  // 将点击事件绑定在body上，实现事件委托或事件代理。
  document.body.addEventListener('click', handleCartClick, false);
</script>
</body>
</html>
```

----------

## 课时111：案例之京东商城放大镜

> 预先估计，和上面跟随差不多，但额外使用了div然后`backgroundImage: position `定位局部图

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson111</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        .box {
            position: absolute;
            width: 450px;
            height: 450px;
            top: 25px;
            left: 50px;
            border: none;
            box-shadow: 3px 3px 10px 0 #111111;
        }

        .box .mark {
            position: absolute;
            top: 0;
            left: 0;
            height: 300px;
            width: 300px;;
            display: block;
            border: 1px solid #aaa;
            background: #fede4f;
            opacity: 0.5;
            filter: alpha(opacity=50);
            z-index: 9;
            cursor: move;
        }

        .box img {
            display: block;
            border: none;
        }

        .box .imgDetail {
            position: absolute;
            top: 0;
            left: 458px;
            height: 540px;
            width: 540px;
            background: url("imgs/iPhone7plus_red_lg.jpg") no-repeat center center;
            background-position: 0 0;
            border: 1px dashed #aaaaaa;
        }
    </style>
</head>
<body>
<div id="box" class="box">
    <img src="imgs/iPhone7plus_red_sm.jpg" alt="iPhone7Plus" id="simg">
    <div class="mark" id="mark"></div>
    <div class="imgDetail" id="imgDetail" style="display: none"></div>
</div>

<script type="text/javascript">
  var box = document.getElementById('box'),
    mark = document.getElementById('mark'),
    imgDetail = document.getElementById('imgDetail');


  function setPoistion(e) {
    // 展示盒子 450px * 450px
    // 放大镜   300px * 300px
    // 明细盒子 540px * 540px
    var left = e.clientX - box.offsetLeft - (mark.offsetWidth / 2),
      top = e.clientY - box.offsetTop - (mark.offsetHeight / 2);
    var minLeft = 0, minTop = 0, maxLeft = box.offsetWidth - mark.offsetWidth,
      maxTop = box.offsetHeight - mark.offsetHeight;
    // 进行边界判断
    if (left > maxLeft) {
      left = maxLeft;
      mark.style.left = maxLeft + 'px';
    } else if (left <= minLeft) {
      left = minLeft;
      mark.style.left = minLeft + 'px';
    } else {
      mark.style.left = left + 'px';
    }
    // 进行边界判断
    if (top > maxTop) {
      top = maxTop;
      mark.style.top = maxTop + 'px';
    } else if (top <= minTop) {
      top = minTop;
      mark.style.top = minTop + 'px';
    } else {
      mark.style.top = top + 'px';
    }
    // 设置放大图的div里的backgroundPosition
    setDetailPosition(left, top);
  }

  function setDetailPosition(l, t) { // 2.6500
    l = -l * 1.77;
    t = -t * 1.77;
    // 这里又要有边界
    //你真别问我边界怎么算出来的，我也不知道，我是拿截图工具量出来的！
    var minL = -259,
      minT = -259;
    l < minL ? l = minL : null;
    t < minT ? t = minL : null;
    imgDetail.style.backgroundPosition = l + 'px ' + t + 'px';
  }

  function handleMouseEnter(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    console.dir(e.target);
    if (e.target.id === 'box') {
      imgDetail.style.display = 'block';
    }
    setPoistion(e);
  }

  function handleMouseLeave(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    if (e.target.id === 'box') {
      imgDetail.style.display = 'none';
    }
  }

  function handleMouseMove(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    e.clientX > box.offsetLeft + box.offsetWidth ? imgDetail.style.display = 'none' : null;
    e.clientY > box.offsetTop + box.offsetHeight ? imgDetail.style.display = 'none' : null;
    setPoistion(e);
  }

  box.addEventListener('mouseenter', handleMouseEnter);
  box.addEventListener('mouseleave', handleMouseLeave);
  box.addEventListener('mousemove', handleMouseMove);
</script>
</body>
</html>
```

----------

## 课时112：案例之百度搜索框

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson112</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
        }

        /*这里如果不指定body的宽高，则它也是个盒子，也是撑不开，导致你就算上了onclick事件也不能触发，因为没宽度啊。*/
        html, body {
            width: 100%;
            height: 100%;
        }

        input {
            display: block;
            outline: none;
        }

        ul, li {
            list-style: none;
        }

        li a {
            display: block;
            text-decoration: none;
            color: #000000;
        }

        li a:hover a:target a:visited a:active {
            text-decoration: none;
            color: #000000;
        }

        .box {
            position: absolute;
            width: 400px;
            top: 20px;
            left: 50%;
            margin-left: -200px;
        }

        .box input {
            padding: 0 10px;
            width: 300px;
            height: 35px;
            margin-bottom: -1px; /*把底下的元素往上吸一个像素*/
            border: 1px solid #008000;
        }

        .box ul {
            display: none;
            position: relative;
            border: 1px solid #008000;
        }

        .box ul li, .box ul li a {
            height: 30px;
            line-height: 30px; /*文字垂直居中*/
        }

        .box ul li a {
            padding: 0 5px;
        }

        .box ul li a:hover {
            background: #cccccc;
        }
    </style>
</head>
<body>

<div id="box" class="box">
    <input type="text" id="searchInp" placeholder="wrods...">
    <ul id="searchList">
        <li><a href="javascript:;">《JavaScript权威指南(第六版)》</a></li>
        <li><a href="javascript:;">《你不知道的JavaScript》</a></li>
        <li><a href="javascript:;">《Node.js实战》</a></li>
        <li><a href="javascript:;">《深入浅出Nodejs》</a></li>
        <li><a href="javascript:;">《JavaScript高级编程(第三版)》</a></li>
    </ul>
</div>

<script type="text/javascript">
  //显示: 1.文本框获取焦点，并且文本框中有内容的时候；2.在文本框中操作(新输入、删除)内容，如果没有清空就显示，否则隐藏；
  //隐藏：1.点击页面其余的位置都隐藏(除了文本框和searchList里面的每一行)都隐藏；2.点击searchList隐藏，但还需要把列表中的内容放到文本框中；

  var searchInp = document.getElementById('searchInp'),
    searchList = document.getElementById('searchList');
  // 不管是获取焦点onfouces，还是在里面编辑内容onkeyup
  searchInp.onfocus = searchInp.onkeyup = function (e) {
    // String.trim();
    var val = this.value.replace(/(^ +| +$)/g, '');
    searchList.style.display = val.length > 0 ? 'block' : 'none';
  };

  function handleSearchList(e) {
    e = e || window.event;
    e.target = e.target || e.srcElement;
    // 如果点击的事件源是searchList下的a
    if (e.target.tagName.toLocaleLowerCase() === 'a' && (e.target.parentNode.parentNode === searchList)) {
      searchInp.value = e.target.childNodes[0].nodeValue;
      searchList.style.display = 'none';
      return;
    }
    // 如果点击的是搜索框，因为存在事件冒泡传播，会从body的click行为上捕获到搜索框再传冒泡到body。则我们不需要触发body的click行为，我们直接跳过。
    //也可以使用手工取消冒泡传播
    //if (e.target === searchInp) {
    //  return;
    //}
    //出停止搜索框的冒泡，这里就有问题。
    searchList.style.display = 'none';
  }

  // 也可以手工在搜索框的click上处理取消冒泡传播
  searchInp.onclick = function (e) {
    e = e || e.event;
    //终止事件在传播过程的捕获、目标处理或起泡阶段进一步传播。兼容IE~~
    e.stopPropagation ? e.stopPropagation() : e.cancelBubble = true;
  };

  //document.body.onclick = handleSearchList;
  document.body.addEventListener('click', handleSearchList);
</script>
</body>
</html>
```

----------

## 课时113：案例之多级菜单js版

- CSS技巧：渐进增强。首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson113</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
            -webkit-user-select: none;
            user-select: none;
        }

        ul, li {
            list-style: none;
        }

        .box {
            margin: 10px;
            padding: 10px;
            width: 300px;
            border: 1px dashed #000000;
            /*渐进增强：首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。*/
            background: #fede4f; /*PC端兼容css3样式，分别对应webkit、火狐、opera、ie*/
            background: -webkit-linear-gradient(to bottom, red 0%, blue 100%);
            background: -moz-linear-gradient(to bottom, red 0%, blue 100%);
            background: -o-linear-gradient(to bottom, red 0%, blue 100%);
            background: -ms-linear-gradient(to bottom, red 0%, blue 100%);
            background: linear-gradient(to bottom, red 0%, blue 100%);
        }

        .box li {
            position: relative;
            line-height: 30px;
        }

        .box em {
            position: absolute;
            top: 7px;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
            background: url("imgs/icon.png") no-repeat -59px -28px;
        }

        .box em.open {
            background-position: -42px -28px;
        }

        .box span {
            display: block;
            padding-left: 20px;
        }

        .box .levelTwo {
            margin-left: 20px;
        }

        .box .levelThree {
            margin-left: 20px;
        }

        .box .levelFour {
            margin-left: 20px;
        }

        .box .levelTwo, .box .levelThree, .box .levelFour {
            display: none;
        }

    </style>
</head>
<body>
<div class="box" id="box">
    <ul>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
    </ul>
</div>
<script type="text/javascript" src="../utils.js"></script>
<script type="text/javascript">
  var box = document.getElementById('box'),
    spanList = box.getElementsByTagName('span');

  // 第一步：循环容器中所有span标签
  for (var i = 0, len = spanList.length; i < len; i++) {
    var curSpan = spanList[i],
      prevEle = utils.prev(curSpan); // 获取该span标签的哥哥元素
    if (prevEle && prevEle.tagName.toLocaleLowerCase() === 'em') {
      // 如果哥哥元素是em的话，说明这个span下还有ul内容，则设置该span样式cursor = "pointer"
      curSpan.style.cursor = "pointer";
    }
  }

  function handleSpanClick(e) {
    e = e || window.event;
    e.traget = e.target || e.srcElement;

    var tagName = e.target.tagName.toLowerCase(), //获取当前点击元素的tagName
      siblingsUlList = utils.children(e.traget.parentNode, 'ul'), // 获取当前点击元素的兄弟元素中ul元素列表
      prevEle = utils.prev(e.target); // 获取当前事件源的哥哥元素

    // 判断是否真的有兄弟ul元素且点击元素时em或者span
    if (siblingsUlList.length > 0 && (tagName === 'em' || tagName === 'span')) {
      // 确定当前点击操作时显示内容还是隐藏内容
      var isHide = tagName === 'span' ? utils.hasClass(prevEle, 'open') : utils.hasClass(e.target, 'open');
      // 遍历循环每一个兄弟ul元素并操作
      for (var i = 0, len = siblingsUlList.length; i < len; i++) {
        // 这里显示和隐藏都只操作兄弟ul元素！
        //isHide ? siblingsUlList[i].style.display = "none" : siblingsUlList[i].style.display = "block";

        //升级业务逻辑。显示时值操作兄弟ul们显示，但隐藏式不仅把兄弟ul们隐藏，还要把子子孙孙ul们都隐藏
        if (isHide) {
          siblingsUlList[i].style.display = "none";
          var u = siblingsUlList[i].getElementsByTagName('ul'); // 获取这个ul底下的所有ul
          var ems = siblingsUlList[i].getElementsByTagName('em'); // 获取这个ul底下的所有em
          for (var iu=0;iu<u.length;iu++) {
            u[iu].style.display = 'none'; // ul的话就直接应酬
          }
          for (var ie=0;ie<ems.length;ie++) {
            utils.removeClass(ems[ie], 'open'); // em的话就直接删除open样式类名
          }
        } else { // 否者显示
          siblingsUlList[i].style.display = "block";
        }
      }

      // 先判断该元素是否为span，如果是就把它哥哥元素的open样式命名进行toggle
      if (tagName === 'span') {
        utils.toggleClass(prevEle, 'open');
      } else { // 如果不是就说明点的是em元素，就直接把本身样式类名open进行toggle开关
        utils.toggleClass(e.target, 'open');
      }
    }
  }
  // 因为有事件冒泡传播，所以为box绑定点击事件，可以让它的子子孙孙元素点击事件传递给box上~~
  box.addEventListener('click', handleSpanClick, false);
</script>
</body>
</html>
```

- 多级菜单Vanilla.js版实现逻辑总结：
  1. 循环容器中所有span标签，拿到每个标签的哥哥元素，如果哥哥元素是em，则说明这个span下还有ul内容，则设置该span样式cursor = "pointer"；
  2. 创建handleSpanClick函数
  3. 函数里，判断事件源所有有兄弟ul元素且事件源是em或者span元素；【是】先拿到该元素所有兄弟ul元素们，然后循环；
  4. 循环里，先判断em元素是否有open样式，如果有则isHide为true，否者为false；
  5. 接上，如果isHide为true，则先让兄弟ul们隐藏，然后获取在每一个兄弟ul元素的子子孙孙节点中过滤出ul和em，分别循环设置隐藏和删除open样式类名；
  6. 接上，如果isHide为false，就直接让兄弟ul们显示；
  7. 接上，toggle点击的em元素样式类名open，handleSpanClick函数完；
  8. handleSpanClick函数绑定到box的click上

----------

## 课时114：案例之多级菜单jquery版

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson114</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
            -webkit-user-select: none;
            user-select: none;
        }

        ul, li {
            list-style: none;
        }

        .box {
            margin: 10px;
            padding: 10px;
            width: 300px;
            border: 1px dashed #000000;
            /*渐进增强：首先设置一个纯色的背景，对于不兼容CSS3的浏览器的话就用纯色；对于兼容的浏览器的话，我们再下面再额外重复增加一个背景渐变色，这样就会把纯色的背景覆盖。*/
            background: #fede4f; /*PC端兼容css3样式，分别对应webkit、火狐、opera、ie*/
            background: -webkit-linear-gradient(to bottom, red 0%, blue 100%);
            background: -moz-linear-gradient(to bottom, red 0%, blue 100%);
            background: -o-linear-gradient(to bottom, red 0%, blue 100%);
            background: -ms-linear-gradient(to bottom, red 0%, blue 100%);
            background: linear-gradient(to bottom, red 0%, blue 100%);
        }

        .box li {
            position: relative;
            line-height: 30px;
        }

        .box em {
            position: absolute;
            top: 7px;
            left: 0;
            width: 16px;
            height: 16px;
            cursor: pointer;
            background: url("imgs/icon.png") no-repeat -59px -28px;
        }

        .box em.open {
            background-position: -42px -28px;
        }

        .box span {
            display: block;
            padding-left: 20px;
        }

        .box .levelTwo {
            margin-left: 20px;
        }

        .box .levelThree {
            margin-left: 20px;
        }

        .box .levelFour {
            margin-left: 20px;
        }

        .box .levelTwo, .box .levelThree, .box .levelFour {
            display: none;
        }

    </style>
</head>
<body>
<div class="box" id="box">
    <ul>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
        <li>
            <em></em><span>第一级第一个</span>
            <ul class="levelTwo">
                <li><span>第二级第一个</span></li>
                <li>
                    <em></em><span>第二级第二个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                        <li>
                            <em></em><span>第三级第三个</span>
                            <ul class="levelFour">
                                <li><span>第四级第一个</span></li>
                                <li><span>第四级第二个</span></li>
                                <li><span>第四级第三个</span></li>
                            </ul>
                        </li>

                    </ul>
                </li>

                <li>
                    <em></em><span>第二级第三个</span>
                    <ul class="levelThree">
                        <li><span>第三级第一个</span></li>
                        <li><span>第三级第二个</span></li>
                    </ul>
                </li>

            </ul>
        </li>
    </ul>
</div>
<script type="text/javascript" src="../jquery-1.12.4.js"></script>
<script type="text/javascript">
  var $box = $('#box');
  // 循环em兄弟span加可点击的样式
  $box.find('span').each(function (i, v) {
    var $item = $(v);
    $item.prev().is('em') ? $item.css('cursor', 'pointer') : null;
  });
  
  function handleBoxClick(je) {
    var $target = $(je.currentTarget),
      $siblingsUls = $target.parent().children('ul'),
      tagName = je.target.nodeName.toLowerCase();
    if ($siblingsUls.length > 0 && (tagName === 'span' || tagName === 'em')) {
      var isHide = tagName === 'span' ? $target.parent().hasClass('open') : $target.hasClass('open');
      $siblingsUls.each(function (item) {
        if (isHide) {
          // 隐藏
          $siblingsUls.slideToggle(); //jQuery: -> defaultSpeed:400ms
          $siblingsUls.find('ul').hide(400); // 这里只能隐藏，不能用toggle
          $siblingsUls.find('em').removeClass('open'); // 这里只能删除，不能用toggleClass
        } else {
          // 显示
          $siblingsUls.slideToggle();
        }
        tagName === 'em' ? $target.toggleClass('open') : $target.prev().toggleClass('open');
      })
    }
  }
  // 将点击时间的行为函数委托给box容器下的em和span元素
  $box.delegate('em, span', 'click', handleBoxClick);

</script>
</body>
</html>
```

----------

## 课时115：拖拽demo实现基本的效果

> 鼠标拖拽的原理：
当鼠标在盒子上按下mousedown的时候，我们开始拖拽（给盒子绑定mousemove和mouseup）；
大概盒子移动时，我们开始计算盒子的最新位置；
当鼠标抬起(放松鼠标左键)时，说明拖拽已经结束，我们over和up就没用了，此时我们把这两个事件方法移除。

![lesson115-mouseDrag.png-56.2kB][2]

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson115</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        #box {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 100px;
            left: 100px;
            /*一种移动端的居中方法，但容器的margin会被设置得viewport宽度的一半！*/
            /*left:0;*/
            /*right: 0;*/
            /*bottom:0;*/
            /*top:0;*/
            /*margin: auto;*/
            /*另一种居中方法，但也会影响容器margin值！*/
            /*top:50%;*/
            /*left:50%;*/
            /*margin-left: -60px;*/
            /*margin-top: -60px;*/
            background: red;
            cursor: move;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript">
  var box = document.getElementById('box');

  function down(e) {
    e = e || window.event;
    //坑1: 如果当前left为0时，返回空字符！
    //坑2：要用BOM提供的实时css啊！
    this["prevLeft"] = parseFloat(window.getComputedStyle(this)['left']) || 0;
    this["prevTop"] = parseFloat(window.getComputedStyle(this)['top']) || 0;
    this["prevX"] = parseFloat(e.clientX);
    this["prevY"] = parseFloat(e.clientY);
    // 当鼠标在box按下时，给box绑定mousemove和mouseup事件
    box.addEventListener('mousemove', move, false);
    box.addEventListener('mouseup', up, false);
  }

  function move(e) {
    e = e || window.event;
    var left = this["prevLeft"] + e.clientX - this["prevX"];
    var top = this["prevTop"] + e.clientY - this["prevY"];
    //边界判断
    var minL = 0, minT = 0,
      // 最大盒子的Left值为，当前viewport宽度 - 整个盒子的宽度
      maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth,
      // 最大盒子的Top值为：当前viewport高度 - 整个盒子的高度
      maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
    // 复杂三元运算符：先判断left小于minL吗，小于就用minL，大于的话(再判断大于maxL吗，大于就用maxL，小于就lefe原值)
    this.style.left = left < minL ? minL : (left > maxL ? maxL : left) + 'px';
    this.style.top = top < minT ? minT : (top > maxT ? maxT : top) + 'px';
  }

  function up(e) {
    e = e || window.event;
    box.removeEventListener('mousemove', move);
    box.removeEventListener('mouseup', up);
  }

  box.addEventListener('mousedown', down, false);
</script>
</body>
</html>
```

----------

## 课时116：拖拽demo解决鼠标丢失

- 当鼠标移动过快时，我们的鼠标会脱离盒子，导致盒子的mouseup和mousemove事件都无法移除，这种现象称为“鼠标焦点丢失”。在IE和火狐内核的浏览器中，我们可以使用一个方法把鼠标和盒子绑定在一起即可-->`setCapture()`和`releaseCapture()`。 

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson115</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        #box {
            position: absolute;
            width: 120px;
            height: 120px;
            top: 100px;
            left: 100px;
            /*一种移动端的居中方法，但容器的margin会被设置得viewport宽度的一半！*/
            /*left:0;*/
            /*right: 0;*/
            /*bottom:0;*/
            /*top:0;*/
            /*margin: auto;*/
            /*另一种居中方法，但也会影响容器margin值！*/
            /*top:50%;*/
            /*left:50%;*/
            /*margin-left: -60px;*/
            /*margin-top: -60px;*/
            background: red;
            cursor: move;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript">
  var box = document.getElementById('box');

  function down(e) {
    e = e || window.event;
    //坑1: 如果当前left为0时，返回空字符！
    //坑2：要用BOM提供的实时css啊！
    this["prevLeft"] = parseFloat(window.getComputedStyle(this)['left']) || 0;
    this["prevTop"] = parseFloat(window.getComputedStyle(this)['top']) || 0;
    this["prevX"] = parseFloat(e.clientX);
    this["prevY"] = parseFloat(e.clientY);
    // 为了解决鼠标焦点丢失问题，在IE和FF中我们使用setCapture和releaseCaptrue。而其它浏览器则我们直接将鼠标move和鼠标up事件绑定在document对象上，妥妥的，不丢失！
    // 当鼠标在box按下时，给box绑定mousemove和mouseup事件
    // 如果当前环境兼容setCapture就启动
    if (this.setCapture) {
      this.setCapture();
      this.addEventListener('mousemove', move, false);
      this.addEventListener('mouseup', up, false);
    } else {
      var self = this;
      // 匿名函数参数必须有e，事件会传递进来
      this["MOVE"] = function (e) {
        move.call(self, e);
      };
      this["UP"] = function (e) {
        up.call(self, e);
      };
      document.onmousemove = this["MOVE"];
      document.onmouseup = this["UP"];
    }

  }

  function move(e) {
    e = e || window.event;
    var left = this["prevLeft"] + e.clientX - this["prevX"];
    var top = this["prevTop"] + e.clientY - this["prevY"];
    //边界判断
    var minL = 0, minT = 0,
      // 最大盒子的Left值为，当前viewport宽度 - 整个盒子的宽度
      maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth,
      // 最大盒子的Top值为：当前viewport高度 - 整个盒子的高度
      maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
    // 复杂三元运算符：先判断left小于minL吗，小于就用minL，大于的话(再判断大于maxL吗，大于就用maxL，小于就lefe原值)
    this.style.left = left < minL ? minL : (left > maxL ? maxL : left) + 'px';
    this.style.top = top < minT ? minT : (top > maxT ? maxT : top) + 'px';
  }

  function up(e) {
    e = e || window.event;
    if (this.releaseCapture) {
      this.releaseCapture();
      this.removeEventListener('mousemove', move);
      this.removeEventListener('mouseup', up);
    } else {
      document.onmousemove = null;
      document.onmouseup = null;
    }
  }

  box.addEventListener('mousedown', down, false);
</script>
</body>
</html>
```

> 关于如何解决因拖拽速度过快导致鼠标焦点丢失后一系列bug修复。

- 首先判断是否为IE(Trident内核)和FireFox(Gecko内核)，如果是可以使用`setCapture()`与`releaseCapture()`方法捆绑和解绑鼠标和当前盒子在一起~~
- 如果不是上面的两者，则可以在down的函数里，将move和up绑定到document对象上，因为鼠标再快也逃不出document对象；绑定上去后，意思就是鼠标就算移动再快，move也跟着鼠标跑，直到你up放开鼠标左键，就删除move和up事件。

----------

## 课时117：dom2级事件基础知识

- 我们使用DOM2级事件绑定，其实是让元素通过原型链一致找到`EventTarget`这个内置类原型上的`addEventListener`方法实现的

- DOM0级事件绑定：只能给元素的某一个行为绑定一次方法，第二次绑定会把之前的覆盖

- DOM2级事件区别一：可以给同一个行为绑定多个不同方法

- DOM2级事件区别二：DOM0级中的行为类型，在DOM2级中一样可以绑定；而且DOM2级中还提供了一些DOM0级没有的行为类型，例如DOMContentLoaded(当页面中的dom树加载完成触发的行为)、

```javascript
window.onload = function () { console.log('ok') };
// 当页面中的所有资源(dom,images,music,vedio...)加载完毕时才会执行后边的函数；并且一个页面中只能用一次，后面写的会把前面的覆盖掉

$(document).ready(function () {}); //==$(function (){})
// 当页面中dom树加载完毕就会执行对应函数；并且可以绑定多次函数
// 原理：dom2级事件 + DOMCotentLoaded实现
```

- dom2级在移除是，必须和定义时的结构一摸一样，否则不能移除。例如绑定是在捕获阶段，移除时移除冒泡阶段的，也不能被移除。

![zf-lesson117.png-31.3kB][3]

- dom2级事件小知识： **（事件池）**
  1. 只能给某个元素的同一行为绑定多个“不同”方法(如果方法相同只保留一个)
  2. 当行为触发，会按照绑定的先后顺序依次把绑定的方法执行
  3. 执行方法中的this就是当前被绑定事件的那个元素本身

- 什么叫作事件池？用来存储当前元素行为绑定方法的容器（浏览器自带）

【事件池图~】

- 在IE6~8中，不支持`addEventListener`和`removeEventListener`，如果想要实现dom2级事件，只能使用`attachEvent`和`detachEvent`代替；但这两个方法只有两个参数，不可以控制在哪个阶段发生，默认都只能在冒泡阶段发生；而且行为类型必须加`on`前缀(与dom0类似)
  - IE的`attachEvent`和`detachEvent`和标准浏览器的事件池机制对比：
  - 区别一：IE6~8【循序问题】执行时其顺序是混乱的，标准浏览器是按照绑定顺序依次执行的！
  - 区别二：IE6~8【重复问题】可以给同一个元素的同一行为绑定相同的方法！
  - 区别三：IE6~8【this问题】当所绑定的方法执行时，方法中的this不是当前元素而是window！

> 以上就是IE6~8中DOM2级事件的兼容问题！
  
----------

## 课时118：don2兼容处理this问题

- 在使用`addEventListener`和`removeEventListener`时，直接第三参数设置为`false`，只能放冒泡阶段，因为`attachEvent`和`detachEvent`只支持冒泡。

- 解决this问题之绑定：先照相，再化妆，然后往自己容器自定义属性中丢一份，再往浏览器自带时间池中丢一份；
- 解决this问题之解绑：通过循环自己容器中自定义属性中拿化妆前的照片去找匹配的对象，找到就直接解绑后再去容器自定义属性中移除，完事。

----------

## 课时119：dom2兼容处理重复问题

- push数组前判断，重复就直接`return`，不留面子！

----------

## 课时120：dom2兼容处理顺序问题

![zf-lesson120.png-199.1kB][4]

- 解决顺序问题，我们不用浏览器自带的事件池，而是用自己模拟标准浏览器事件池的实现!

```javascript
//创建事件池，并且把需要给当前元素绑定的方法依次的增加到事件池中
function on(curEle, type, fn) {
  //判断当前元素的某行为事件池是否存在，不存在就赋空数组
  !curEle["myEvent" + type] ? curEle["myEvent" + type] = [] : null;
  var ary = curEle["myEvent" + type];
  for (var i = 0, len = ary.length; i < len; i++) {
    var cur = ary[i];
    if (cur === fn) return;
  }
  ary.push(fn);
  //curEle.addEventListener(type, run, false);//执行on的时候随带给当前元素绑定一个点击行为，点击时执行run方法，run方法中this是当前元素curEle，并且浏览器给run传递了一个MouseEvent事件对象
  bind(curEle, type, run); //使用已经实现兼容且处理过重复和this问题的绑定方法
}
//在自己的事件池中吧某一个方法移除
function off(curEle, type, fn) {
  var ary = curEle["myEvent" + type];
  for (var i=0, len=ary.length; i< len; i++) {
    if (ary[i] === fn) {
      ary.splice(i,1);
      break;// 完全不需要执行行为，仅仅是删除事件池中的事件而已。
    }
  }
}

// 只给当前元素的点击行为绑定一个方法润，当触发某行为时执行的也就是run方法，我们在run方法中根据自己存储的方法新顺序分别执行所这些方法即可
function run(e) {
  e = e || window.event;
  var flag = !!e.target; // 判断当前浏览器是否是IE6~8，false为IE6~8
  if (!flag) {
    // 处理IE兼容问题
    e.target = e.target || e.srcElement;
    e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
    e.pageY = e.clientY + (document.documentElement.scrollTop || document.body.scrollTop);
    e.preventDefault = function () {
      e.returnValue = false;
    };
    e.stopPropagation = function () {
      e.cancelBubble = true;
    }
  }

  // 获取自己事件池中绑定的那些方法，并且让这些方法依次执行
  var ary = this["myEvent" + e.type];
  for (var i = 0, len = ary.length; i < len; i++) {
    ary[i].call(this, e); // 执行时记得修改this和传递mouseEvent对象~
  }
```

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson 120</title>
    <style type="text/css">
        #box {
            position: absolute;
            width: 100px;
            height: 100px;
            top: 50px;
            left: 400px;
            background: red;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript" src="../event.js"></script>
<script type="text/javascript">
  var box = document.getElementById('box'),
      count = 0;

  function fn1() {
    console.log(1);
  }
  function fn2() {
    console.log(2);
  }
  function fn3() {
    console.log(3);
  }
  function fn4() {
    console.log(4);
  }
  function fn5() {
    console.log(5);
  }
  function fn6() {
    console.log(6);
  }
  function fn7() {
    console.log(7);
  }
  function fn8() {
    console.log(8);
  }
  function fn9() {
    console.log(9);
    count++;
    if(count>= 3) {
      off(box, 'click', fn1);
      off(box, 'click', fn9);
      //return; // 如果return注释掉的话，就能输出三次9！
    }
  }

  on(box, 'click', fn1);
  on(box, 'click', fn2);
  on(box, 'click', fn3);
  on(box, 'click', fn4);
  on(box, 'click', fn5);
  on(box, 'click', fn6);
  on(box, 'click', fn7);
  on(box, 'click', fn8);
  on(box, 'click', fn9);
</script>
</body>
</html>
```

----------

## 课时121：复习专用-dom2兼容处理 this问题

```javascript
// -> 标准浏览器中
var fn = function () { };
document.addEventListener('click', fn);
document.removeEventListener('click', fn);

// -> IE6~8浏览器中
document.attachEvent('onclick', fn);
document.detachEvent('onclick', fn);

// 完整代码在122
```

----------

## 课时122：复习专用-dom2兼容处理顺序问题

- 课时121和课时122都是复习课，时间讲的长了点，我稍后用自己画的三个图(bind实现原理图、标准浏览器事件池原理图和自己实现事件池原理图)再次复习并复写事件库就算过关了。

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>lesson121</title>
    <style type="text/css">
        #box {
            position: absolute;
            left: 300px;
            top: 200px;
            width: 200px;
            height: 200px;
            background: red;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript" src="zyEvent.js"></script>
<script type="text/javascript">
  // 标准浏览器和IE6~8浏览器之间关于dom2级事件机制的一些重要区别：
  // 1.this问题：标准浏览器中给一个元素的某一个行为绑定方法，当行为触发执行对应方法时，方法中的this就是当前元素；而在IE6~8，此方法执行时方法中的this却是window。
  // 2.重复问题：标准浏览器中不能给同一元素的同一行为绑定多个相同的方法；但在IE6~8中query可以绑定；
  // 3.顺序问题：标准浏览器绑定行为时，是按照顺序依次把方法添加打到事件池中，在下一次添加时，首先看现有事件池中是否已有这个方法，如果重复就不再添加，并且当行为在触发时，会到事件池中按照添加的顺序依次执行方法；而在IE6~8中，所绑定的方法并不按顺序执行，是无序的。

  var box = document.getElementById('box');

  function fn1 (e) {
    console.log('绑定成功');
    console.dir(e);
    console.dir(this);
    unbind(box, 'click', fn1);
    console.log('解绑成功');
  }

  function fn2 (e) {
    console.log('绑定：鼠标在box元素里按下了');
    off(box, 'click', fn2);
    console.log('解绑成功');
  }

  bind(box, 'click', fn1);
  on(box, 'click', fn2);
</script>
</body>
</html>
```

```javascript
Function.prototype.myBind = function myBind(context) {
  // 实现bind，原理是匿名函数外包一层，每次执行myBind就产生一个新作用域
  // 用的时候这样用hi.myBind(obj)，这个时候返回的是一个堆内存和与之链接的作用域
  // 这个时候我们要先将this保存起来，这个this就是hi方法的堆内存地址~
  var _this = this;
  // 接收一下用myBind时传入的外层参数，注意，这里arguments是类数组
  // 这里从索引1开始转数组，索引0是context不需要。
  var outerArg = Array.prototype.slice.call(arguments, 1);
  // 可以准备返回堆内存了，就是返回匿名函数~
  return function () {
    // 进来首先也是准备接收它的参数，这里得从索引0开始转换数组了
    var innerArg = [].__proto__.slice.call(arguments, 0);
    // 准备要执行了，我们先去上级作用域拿到要修改this的方法hi的堆内存，在_this中保存
    // 替换hi方法的this用上级作用域传入形参context~
    // 链接两个参数数组时，注意顺序，outer后面跟inner
    _this.apply(context, outerArg.concat(innerArg));
  }; // 打完收工
};
/////////////↓↓↓↓↓以下是myBind测试↓↓↓↓↓///////////////
//   function hi(one, two) {
//     console.log(this.hello + ', ' + one + ' ' + two + '.')
//   }
//
//   var o = {hello: 'hello'};
//   hi.myBind(o, 'jerry')('shi'); //直接执行
//   var fn1 = hi.myBind(o, 'jerry'); //赋值堆地址等待执行
//   fn1('shi');
/////////////↑↑↑↑↑以上是myBind测试↑↑↑↑↑///////////////

function bind(curEle, type, fn) {
  // 兼容性判断，如果兼容就用标准浏览器的方法
  if ("addEventListener" in window) {
    curEle.addEventListener(type, fn);
    return;
  }
  // 以下为IE6~8
  // 取出当前元素事件池数组
  // 判断事件池是否存在，不存在赋值空数组
  var ary = curEle['zyBind' + type];
  ary = ary ? null : [];
  // for循环检测该方法是否已经存在事件池中
  for (var i = 0, len = ary.length; i < len; i++) {
    // 取包装前的原始对象对比
    if (ary[i].proto === fn) {
      // 如果存在则直接return整个函数(先退for循环后再退整个函数)，不能重复绑定
      return;
    }
  }
  // 过了上面的检查，再创建一个包装对象
  // var tmpFn = function (e) {
  //   fn.call(curEle, e);
  // };
  var tmpFn = fn.myBind(curEle);
  // 将这个包装对象的原始对象也存入自定义属性，为了辨认！
  // 我靠，我才发现这里是给函数这个对象添加自定义属性，对于JS这门语言我也是醉了~
  tmpFn.proto = fn;
  // 将包装对象存入元素事件池数组
  ary.push(tmpFn);
  curEle.attachEvent("on" + type, tmpFn);
}

function unbind(curEle, type, fn) {
  if ("removeEventListener" in window) {
    curEle.removeEventListener(type, fn);
    return;
  }
  // 以下为IE6~8
  var ary = curEle['zyBind' + type];
  if (ary) {
    for (var i = 0; i < ary.length; i++) {
      if (ary[i].proto === fn) {
        // 删除IE绑定
        curEle.detach("on" + type, curEle.proto);
        // 删除当前元素事件池数组上的该方法
        ary.splice(i, 1);
        return; // 删除完成直接退出整个函数
      }
    }
  }
}

function on(curEle, type, fn) {
  // zyBind 和 zyEvent是两个数组~
  // 这里如果事件池不存在undefined，ary就是undefined，
  // 意思就是ary没拿到内存地址，赋值个空数组给undefined也没意思
  //curEle['zyEvent' + type] ? null : curEle['zyEvent' + type] = [];
  !curEle["zyEvent" + type] ? curEle["zyEvent" + type] = [] : null;
  var ary = curEle['zyEvent' + type];
  for (var i = 0, len = ary.length; i < len; i++) {
    if (ary[i] === fn) return;
  }
  // 检查通过后将方法存在事件池数组中
  ary.push(fn);
  // 注意：因为bind方法里我们处理了重复问题，所以可以重复绑定run方法，没事
  bind(curEle, type, run);
}

function off(curEle, type, fn) {
  // off就简单了，只需要操作一下事件池数组就行了
  var ary = curEle['zyEvent' + type];
  if (ary) {
    for (var i = 0; i < ary.length; i++) {
      if (ary[i] === fn) {
        ary.splice(i, 1);
        // ary[i] = null;
        return;
      }
    }
  }
}

// run方法将会绑定到元素有触发的所有行为上，
//   通过run方法获取该元素自定义属性对应的行为事件池池的数组，然后逐一执行。
function run(e) {
  // 在bind方法里，会将行为触发全部绑定到run上，run如要做的就是拿到元素和事件类型
  e = e || window.event;
  var flag = !!e.target;
  if (!flag) { // 判断兼容并处理
    e.target = e.target || e.srcElement;
    e.pageX = e.clientX + (document.documentElement.scrollLeft || document.body.scrollLeft);
    e.pageY = e.clientY + (document.documentElement.scrollHeight || document.body.scrollTop);
    e.preventDefault = function () {
      e.returnValue = false;
    };
    e.stopPropagation = function () {
      e.cancelBubble = true;
    }
  }
  var type = e.type, ary = this['zyEvent' + type];
  // ary = e.target['zyEvent' + type];
  if (ary) {
    // for (var i = 0; i < ary.length; i++) { 不能这样设置len了，因为要删除数组，用这方式会数组塌陷！
    for (var i = 0; i < ary.length; i++) {
      if (typeof(ary[i]) === "function") {
        ary[i].call(this, e); // 传入当前元素this和Event对象
      } else {
        // 如果不是函数直接删除当前项
        ary.splice(i, 1);
        i--;
      }
    }
  }
}
```

----------

## 课时123：复习专用-使用自己的事件库

- 使用自己的事件库完成课时120的拖拽练习

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>lesson123</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
        }

        html, body {
            height: 100%;
            width: 100%;
        }

        #box {
            position: absolute;
            left: 200px;
            top: 200px;
            width: 120px;
            height: 120px;
            background: red;
        }
    </style>
</head>
<body>
<div id="box"></div>
<script type="text/javascript" src="zyEvent.js"></script>
<!--<script type="text/javascript" src="../event.js"></script>-->
<script type="text/javascript">
  var box = document.getElementById('box');

  function down(e) {
    // 记录当鼠标按下时的初始状态
    this['prevX'] = parseFloat(e.clientX);
    this['prevY'] = parseFloat(e.clientY);
    this['prevLeft'] = parseFloat(window.getComputedStyle(this)['left']);
    this['prevTop'] = parseFloat(window.getComputedStyle(this)['top']);
    // 处理鼠标过快丢失焦点问题
    // 首先检测是否在ie和火狐环境
    if (this.setCapture) {
      this.setCapture();
      on(box, 'mousemove', move);
      on(box, 'mouseup', up);
    } else { // 如果是chrome环境就把move和up绑定在document上！
      // 保存this，为了传递
      var _this = this;
      // 将
      this['dMove'] = function (e) {
        move.call(_this, e);
      };
      this['dUp'] = function (e) {
        up.call(_this, e);
      };
      on(document, 'mousemove', this['dMove']);
      on(document, 'mouseup', this['dUp']);
    }
  }

  function move(e) {
    var left = this['prevLeft'] + (parseFloat(e.clientX) - this['prevX']);
    var top = this['prevTop'] + (parseFloat(e.clientY) - this['prevY']);
    // 设置边界极值
    // 获得公式：html/body的内容宽/高 - 整个盒子的宽/高
    var minL = 0, maxL = (document.documentElement.clientWidth || document.body.clientWidth) - this.offsetWidth;
    var minT = 0, maxT = (document.documentElement.clientHeight || document.body.clientHeight) - this.offsetHeight;
    // 处理边界问题
    box.style.left = left < minL ? minL : (left > maxL ? maxL : left) + 'px';
    box.style.top = top < minT ? minT : (top > maxT ? maxT : top) + 'px';
  }

  function up(e) {
    //判断是否在IE和火狐
    if (this.releaseCapture) {
      this.releaseCapture();
      off(box, 'mousemove', move);
      off(box, 'mouseup', up);
    } else {
      off(document, 'mousemove', this['dMove']);
      off(document, 'mouseup', this['dUp']);
    }
  }

  on(box, 'mousedown', down);
</script>
</body>
</html>
```

----------

## 课时124：弹性势能动画 抛物线运动

```javascript

```



  [1]: http://static.zybuluo.com/szy0syz/l5ie96tnnns94qvvmdoau62u/zf-lesson107.png
  [2]: http://static.zybuluo.com/szy0syz/wli79p74bzsuqvlqm6hgzfkm/lesson115-mouseDrag.png
  [3]: http://static.zybuluo.com/szy0syz/1hyf18t8bdk9noxne0pdrvjp/zf-lesson117.png
  [4]: http://static.zybuluo.com/szy0syz/yk5rfstg2uaokp56lrvo2qxy/zf-lesson120.png
  
  
