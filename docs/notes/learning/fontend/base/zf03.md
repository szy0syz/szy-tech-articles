# 珠峰前端全栈培训第三周：dom盒子模型实战和dom库封装

## 课时48：盒子模型常用的属性(前8个)

***JavaScript盒子模型指的是通过JS提供的一些列属性和方法，获取页面中元素的样式信息值(就是获取dom对象后操作那些关于样式的属性和方法)***

![image.png-72.1kB][1]

内容的宽度和高度就是我们设置的width和height这两个样式就是内容的宽和高，如果没有设置高度值，容器的高度会根据里面内容自己进行适应，这样获取的值就是真实内容的高；如果设置了固定的高度了，不管内容是多少了还是少了，其内容的高度会固定为我们设置的那个值。

真实的内容的高度和宽度：这个代指的是我们实际内容的高度(和我们设置的height没有必然关系)，例如：我们设置高度为200px，如果内容有溢出，那么真是内容的高度会把溢出内容的高度也加进来。

#### client系列属性
- clientHeight/clientWidth：内容+上下或左右padding填充的值(和内容是否溢出没关系)
- clientLeft/clientTop：左边框的宽度/上边框的高度 (就是border[Left/Top]Width)

#### offset系列属性

- offsetHeight/offsetWidth：全等于(clientHeight+上下border边框)/(clientWidth+左右border边框) -> 同样的和内容是否溢出没有任何关系
- offsetParent：当前元素的父级参照物
- offsetLeft/offsetTop：当前元素的外边框距离父级参照物内边框的偏移量

#### scroll系列属性

- scrollHeight/scrollWidth
  - 在内容没溢出的前提下，两者和clientHeigth/clientWidth一样；
  - 在内容有溢出的前提下，两者获取的值有如下规则：scrollHeight为真实内容的高度(包含溢出)+上padding填充，scrollWidth为真实内容的宽度+左padding填充；两者获取的结果值都是“约等于”的值，因为在统一浏览器中，我们是否设置了css样式`overflow:'ha  dden'`对于最终的结果是有影响的；在不同浏览器中我们回去的结果值也是不同(IE6~7)

- scrollLeft/scrollTop：滚动条卷去的宽度或高度

#### 关于JavaScript盒子模型取值的问题

- 我们通过👆上面👆这13个属性值

#### 关于操作浏览器本身的盒子模型信息

```javascript
document.documentElement.scrollTop // -> 我们发现这货哈哈都是0，不会变！
document.body.scrollTop // -> 又发现这货会随着滚动条而改变，你设置它后浏览器的实际滚动条都会改变！
```

- 对于浏览器来说，clientWidth和clientHeight是当前可见区域(下面可能还有内容)的宽和高
- scrollWidth/scrollHeight就是当前页面的真实宽度和高度(所有要显示内容加起来的宽高，但是个约等于值，若有懒惰加载的图片会影响高度)
- 仅对操作浏览器页面---->我们不管要读写哪些属性，也不管是用什么浏览器，想要都兼容的话，需要读写两套属性：
  - `document.documentElement[attr] || document.body[attr]` 
  - 而且在操作时必须`document.documentElement[attr]`先操作

```javascript
// [获取当前页面的真实宽度或高度]
var winHeight = document.documentElement.clientWidth || document.body.clientWidth
// [设置当前页面滚动条的高度]
document.documentElement.scrollTop = 1000
document.body.scrollTop = 1000

// 封装一个函数，实现对浏览器各项属性的读写
function win (attr, val) {
  if (!attr) {
    return document.documentElement[attr] || document.body[attr]
  }
  document.documentElement[attr] = val
  document.body[attr] = val
}
```

----------

## 课时49：获取元素的具体样式信息


- 元素.style.属性名 -> `xxxx.style.height` -> 这样js获取的是某个dom元素的CSSStyleDeclaration行内样式属性，不能索取到在样式表中设置的height值。真实项目中不常用，因为不能把所有样式都写在行内样式上，这样无法实现css和html的分离。

- window.getComputedStyle：方法获取所有经过浏览器计算过的样式
  - 所有经过浏览器计算过的样式：只要当前的元素标签可以在页面中呈现出来，那么它的所有的样式都是经过浏览器计算(渲染)过的，哪怕有些样式没写，我们也可以获取到。
  - 此方法虽然好用，但在IE6~8下不兼容，因为window下没有getComputedStyle方法
  - 在IE6~8下，可以使用`window.currentStyle`方法来获取所有通过浏览器渲染过的样式

```javascript
window.getComputedStyle // -> function getComputedStyle() { [native code] }
window.getComputedStyle(box, null) // 返回CSSStyleDeclaration这个类的实例，其包含了当前元素的所有样式和值
// window.getComputedStyle(参数1, 参数2) 参数1写dom元素，参数2为当前元素的伪类(一般不用伪类故写null)

// 方法getCss：兼容(ie6~8)方式获取元素当前所有经过浏览器计算渲染过的样式中的[attr]对应的值
// curEl, dom对象
// attr, 样式的属性名
function getCss (curEl, attr) {
  // 方法1：使用try catch处理兼容
  // 此方法问题：必须保存try中的代码在不兼容浏览器中执行时报错，才可以用catch捕获到异常信息进行处理。而不管是什么浏览器都需要执行try中的代码，如果已经是在IE6~8中，也要执行一遍去报错了才处理，浪费性能。
//  try {
//    return window.getComputedStyle(curEl, null)[attr]
//  } catch (e) {
//    console.log('你竟然在用IE6~8！')
//    return curEl.currentStyle[attr]
//  }

  // 方法2：提前判断window对象是否有getComputedStyle属性
//  var val = null
//  if("getComputedStyle" in window) {
//    val = window.getComputedStyle(curEl, null)[attr]
//  } else {
//    val = curEl.currentStyle[attr]
//  }

  // 方法3：通过检查浏览器版本和类型来处理兼容
  // -> window.navigator.userAgent
  // MAC Chrome -> "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_4) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36"
  if (/MSIE [678]/.test(window.navigator.userAgent)) {
    return window.getComputedStyle(curEl, null)[attr]
  } else {
    return curEl.currentStyle[attr]
  }
}
// getCss(box, "border") // 在IE6~8中还是没有
// getCss(box, "borderTop") // 把复合值拆开来写避免出现不兼容问题
// 对于标准浏览器和IE浏览器获取的结果还是不一样的 -> 对于部分样式，不同浏览器结果不一样，主要由于getComputedStyle和currentStyle在某些方面还是有不一样的。
```

***写CSS的时候，最好第一步初始化默认样式，避免浏览器之间的差异，而且写的默认样式对于JS以后获取到的统一结果也是很有帮助***

- getCss第一次升级

```javascript
function getCss (curEl, attr) {
  var val = null
  var reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/
  // var val = reg = null , 这样写reg就被整成全局了！
  if ("getComputedStyle" in window) {
    val = window.getComputedStyle(curEl, null)[attr]
  } else {
    val = curEl.currentStyle[attr]
  }
  // 返回前必须处理复合值，如padding background，position，float等
  // 匹配：负号可有可无后再跟1到多为数字, 小数部分可有可无，单位符号可有可无
  return reg.test(val) ? parseFloat(val) : val
}
```

- ***getCss第二次升级：针对有些IE6~8不兼容opacity属性***

```javascript
// getCss: 兼容(ie6~8)方式获取元素当前所有经过浏览器计算渲染过的样式中的[attr]对应的值
// opacity: 0.5; /*透明度，在IE6~8中不兼容*/
// fliter: alpha(opacity=10); /*兼容方法使用滤镜来处理*/
function getCss (curEl, attr) {
  var val = null
  // 匹配：负号可有可无后再跟1到多为数字, 小数部分可有可无，单位符号可有可无
  var reg = /^-?\d+(\.\d+)?(px|pt|rem|em)?$/
  // var val = reg = null , 这样写reg就被整成全局了！
  if ("getComputedStyle" in window) {
    val = window.getComputedStyle(curEl, null)[attr]
  } else { // -> 如果是IE6~8
    if (attr === 'opacity') {
      val = curEl.currentStyle[attr]
      // 正则解释：alpha开头，小括号字符需用转义符转义，然后括号里是1到多位数，后面小数部分可有可无，里面?:指明不捕获内容，最后忽略大小写
      reg = /^alpha\(opacity=(\d+(?:\.\d+)?)\)$/i
      // 先匹配，在捕获第一个小正则内容，如果不是就返回1
      val = reg.test(val) ? reg.exec(val)[1] / 100 : 1
    } else {
      val = curEl.currentStyle[attr]
    }
  }
  // 返回前必须处理复合值，如padding background，position，float等
  return reg.test(val) ? parseFloat(val) : val
}
```

----------

## 课时50：伪类的应用

```css
/* :before  :after  -> 在一个元素标签的前面或后面创建一个新的虚拟的标签，可以给这个虚拟标签增加css样式或者内容等...*/
.box p:before {
    display: block;
    background: lightgreen;
    content: "我是老司机";
    text-align: center;
}

.box p:after {
    display: block;
    background: lightblue;
    content: "开车上省城";
    text-align: center;
}

/*-------------消除浮动--------------*/
.clear {
    zoom: 1;
}

.clear:after {
    display: block;
    width: 0;
    height: 0;
    content: "";
    overflow: hidden;
    clear: both;
}
```

```javascript
// 获取伪类的内容，也可以样式
var p1 = document.getElementById("boxP")
window.getComputedStyle(p1,"before").content // -> "我是老司机"
window.getComputedStyle(p1,"before").background
```

----------

## 课时51：获取元素的偏移量

```html
<div id="outer">
    <div id="inner">
        <div id="center">
        </div>
    </div>
</div>
```

- `patentNode`：父节点属性，html结构层级关系中的上一级节点！

```javascript
center.parentNode //-> inner element
inner.parentNode // -> outer element
outer.parentNode // -> body element

document.parentNode // ->  null (根节点) -> 引擎自带的属性：父节点属性
document.parentnode // ->  undefiend -> 对象上没这个属性
// 从上面的例子体现出null和undefined的区别：
// 两者都是表示没有
// null表示属性是存在的只是值没有，而undefined表示属性根本不存在
// 葛大大的女朋友还没找到就是null，葛大大的男朋友就本身就没有undefined
```

- `offsetParent`：父级参照物，在同一平面中，最外层的元素是里面所有元素的父级参照物(与HTML的node层级结构没关系)
  - 一般来说，一个页面中所有元素的父级参照物都是`body`
  - 想要改变父级参照物，需要通过修改CSS中`position`定位来实现

```javascript
center.offsetParent // -> body element
inner.offsetParent // ->  body element
outer.offsetParent // ->  body element
document.body.offsetParent // -> null
```

```css
/* 只有这三个样式的属性可以改变元素父级参照物！
position: absolute; 
position: fixed;
position: relative;
*/
```

- `offsetLeft`：元素左外框距离父级参照物的距离

![image.png-25.6kB][2]

```javascript
// 修改最外层div的定位为：相对定位
outer.style.position = "relative"
center.offsetParent  // -> outer element
inner.offsetParent  // ->  outer element
outer.offsetParent  // ->  body element

// 修改两层div的定位为：相对定位
outer.style.position = "relative"
inner.style.position = "relative"
center.offsetParent  // -> inner element
inner.offsetParent  // ->  outer element
outer.offsetParent  // ->  body element
```

- 以上代码结论：当修改某个元素position为relative时，会将其所有下级节点的父级参照物都设置为该元素；而如果有嵌套的relative定位，则父级参照物会呈树形结构。

```javascript
// 获取一个元素相对于body的offset偏移量
// 这里对于父级参照物设置了relative、fixed、absolute的情况都进行了补偿
function offset (curElement) {
    var totalLfet = 0, totalTop = 0, parant = curElement.offsetParent
    // 先算自己的
    totalLfet += curElement.offsetLeft
    totalTop += curElement.offsetTop

    while (parant) {
        // 判断是不是IE8
        if (window.navigator.userAgent.indexOf("MSIE 8.0") === -1) {
            // 累加父级参照物的边框
            totalLfet += parant.clientLeft
            totalTop += parant.clientTop
        }
        // 累加父级外边框到上级参照物的距离
        totalLfet += parant.offsetLeft
        totalTop += parant.offsetTop
        // 重新设置父级参照物
        parant = parant.offsetParent
        }
    return {left: totalLfet, top: totalTop}
}
```

![HTMLElement_offsetLeft_plus.png-119.5kB][3]

----------

## 课时52：浏览器滚动条卷去的高度scrollTop

> 在之前在JavaScript盒子模型中：client系列、offset系列和scrollWidth/scrollHeight都是[只读]属性 -> 只能通过属性获取，不能通过属性修改元素的样式！

> 但scrollTop和scrollLfet：滚动条卷去的高度和宽度，则是[可读写]的属性！

- `scrollTop`的值是存在边界值(最小值和最大值)，我们设置的值比最小值小或者比最大值打都没用，返回的依然是边界值，即返回最小值或者最大值。
  - 最小值 = 0
  - 最大值 = `curElement.scrollHeight - curElement.clientHeight`

```html
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-family: "微软雅黑";
            font-size: 14px;
            /*禁止用户选中文字*/
            -webkit-user-select: none;
            /*兼容非webkit处理*/
            user-select: none;
        }

        html,
        body {
            width: 100%;
            /*让页面高度为5个屏幕高度*/
            height: 500%;
            background: lightgreen;
            /*CSS3 背景颜色渐变实现*/
            background: -webkit-linear-gradient(top, lightgreen, lightcoral, lightcyan, lightblue, limegreen, lightgray, lightsalmon);
            background: webkit-linear-gradient(top, lightgreen, lightcoral, lightcyan, lightblue, limegreen, lightgray, lightsalmon);
        }

        a {
            /*让a标签没有下划线*/
            text-decoration: node;
            color: #000000;
        }

        a:hover,
        a:active,
        a:visited,
        a:target {
            text-decoration: none;
            color: #000000;
        }

        #goTop {
            /*display: block;*/
            /*设置了position后自然成块级元素*/
            position: fixed;
            bottom: 80px;
            right: 50px;
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            background: red;
            /*CSS3盒子圆角*/
            border-radius: 50%;
            opacity: 0.2;
            /*为兼容老浏览器*/
            filter: alpha(opacity=20);
        }
        /*设置那个id为goTop的A标签的hover伪类(状态)的样式*/
        #goTop:hover {
            opacity: 1;
            filter: alpha(opacit=100);
        }
    </style>
</head>

<body>
    <!--a便签本身是做页面跳转的，
      1.如果href值为空则效果为刷新本页面
      2.如果href值为#id，则为锚点定位，将scrollTop值设为元素相对body的距离，也就是定为该元素。
      3.如果href值为“javascript:;”，则表示取消a标签的默认跳转行为
    -->
    <a href="javscript:;" id="goTop">Top</a>

    <script type="text/javascript">
        var goTop = document.getElementById("goTop")
        goTop.onclick = function () {
            document.documentElement.scrollTop = 0;
            document.body.scrollTop = 0;
        }
    </script>
</body>
</html>
```

----------

## 课时53：实战项目-回到顶部

#### 定时器

```javascript
// 设置定时器(setTimeout)，等到1000ms后执行对应方法，方法执行完成后，定时器结束。
window.setTimeout(function () {}, 1000)

// 设置定时器(setInterval)，等到1000ms后开始执行对应的方法，方法执行完成后，定时器并没有结束，之后每隔1000ms定时器都会把方法执行一次，直到手动清除定时器为止
window.setInterval(function () {}, 1000)

// 设置定时器的时候是有返回值的，返回结果是一个数字，代表当前是第几个定时器
var timer1 = window.setTimeout(function () {}, 1000)
console.log(timer1)  // -> 1
var timer2 = window.setTimeout(function () {}, 1000)
console.log(timer2)  // -> 2
var timer3 = window.setInterval(function () {}, 1000)
console.log(timer3)  // -> 3
window.clearTimeout(1)  // 清除定时器时，参数为一个数字，表示清除第几个定时器
window.clearInterval(timer2) // 使用setTimeout声明，但可以使用clearInterval清除

// 关于多次动画的实现
// 1. 使用setInterval实现简版多次动画效果
var n = 0
var timer = window.setInterval(function () {
  n++
  console.log(n)
  if (n === 5) {
    window.clearInterval(timer)
  }
}, 1000)

// 2. 使用setTimeout实现简版多次动画效果
// 首先明白工setTimeout就不需要请计数器了
var n = 0
var timer = null
function move () {
  n++
  console.log(n)
  if (n === 5) return
  timer = window.setTimeout(move, 1000)
}
// 执行前必须再包一层，要不然立马就打1出来，和上面的不一样
window.setTimeout(move, 1000)
```

```javascript
// 一个坑，小心
document.body.clientHeight             // -> 【页面最大高度】
document.documentElement.clientHeight  // -> 【一个浏览器可视页面最大高度】
```

- 关于获取当前浏览器可视页面宽和高的记录

```javscript
// 一般来说以下方式获取浏览器可视页面的高度
var curHeight = document.documentElement.clientHeight || document.body.clientHeight

// 但如果说 CSS中加了以下属性后
// html, body { height: 500% }
// document.documentElement.clientHeight 的高度就会被放大5倍
// document.body.clientHeight 的高度还是浏览器可现实页面的高度
```

```html
<html>
<head>
    <meta charset="UTF-8">
    <title>Document</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-family: "微软雅黑";
            font-size: 14px;
            /*禁止用户选中文字*/
            -webkit-user-select: none;
            /*兼容非webkit处理*/
            user-select: none;
        }

        html, body {
            width: 100%;
            /*让页面高度为5个屏幕高度*/
            height: 500%;
            background: lightgreen;
            /*CSS3 背景颜色渐变实现*/
            background: -webkit-linear-gradient(top, lightgreen, lightcoral, lightcyan, lightblue, limegreen, lightgray, lightsalmon);
            background: linear-gradient(top, lightgreen, lightcoral, lightcyan, lightblue, limegreen, lightgray, lightsalmon);
        }

        a {
            /*让a标签没有下划线*/
            text-decoration: none;
            color: #000000;
        }

        a:hover,
        a:active,
        a:visited,
        a:target {
            text-decoration: none;
            color: #000000;
        }

        #goTop {
            /*display: block;*/
            /*设置了position后自然成块级元素*/
            position: fixed;
            bottom: 80px;
            right: 50px;
            width: 50px;
            height: 50px;
            line-height: 50px;
            text-align: center;
            background: red;
            /*CSS3盒子圆角*/
            border-radius: 50%;
            opacity: 0.2;
            /*为兼容老浏览器*/
            filter: alpha(opacity=20);
            /*默认隐藏*/
            display: none;
        }

        #goTop:hover {
            opacity: 1;
            filter: alpha(opacity=100);
        }
    </style>
</head>

<body>
    <a href="javascript:;" id="goTop">Top</a>

    <script type="text/javascript">
        var goTop = document.getElementById("goTop");

        // window.onscroll = handler;
        // 使用DOM二级事件升级
        window.addEventListener("scroll", handler, false);

        function handler () {
            if (currentScrollTop() < getCurrentScreenHeight()) {
                goTop.style.display = "none"
            } else {
                goTop.style.display = "block"
            }
        }

        goTop.onclick = function () {
            // 当点击了goTop后，清除滚动条事件监听
            //window.onscroll = null;
            // 使用DOM二级事件升级
            window.removeEventListener("scroll", handler, false);
            // 让goTopy隐藏
            goTop.style.display = "none";
            var step = (currentScrollTop() / 100).toFixed(); // 获取当点击时滚动条卷去的高度再除以100为步长,简单来说就是滚100哈滚到头
            var timer = window.setInterval(function () {
                var target = currentScrollTop() - step;
                currentScrollTop(target); // 设置滚动条
                if (currentScrollTop() === 0) {
                    window.clearInterval(timer) // 清除计时器
                    window.onscroll = handler; // 待完成后重新把事件绑定上
                }
            }, 5); //5ms
        };

        function currentScrollTop (num) {
            if(num === undefined) return document.documentElement.scrollTop || document.body.scrollTop;
            document.documentElement.scrollTop = num;
            document.body.scrollTop = num;
        }
        // 当前浏览器可视页面的高度
        function getCurrentScreenHeight () {
            // 单独为了处理 html,body{height:500%}的情况
            if(document.documentElement.clientHeight !== 0 && document.documentElement.clientHeight > document.body.clientHeight) return document.body.clientHeight;
            return document.documentElement.clientHeight || document.body.clientHeight;
        }
    </script>
</body>
</html>
```

----------

## 课时53：作业题-京东首页导航栏实现

- ver1
  - 第一个版本，直接把京东首页整页截图，然后用10个div把图片分为12个部分，虽然功能都实现了，但导航栏的同步很不完美啊，为了和京东首页的导航栏同步率高达98.47%，还是把所有板块都分开截图，分开放在12个div里。

- ver2
  - 首页截图细分12个板块 
 
----------

## 课时54：实战项目-跑马灯

```html
<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>滚动条显示文字</title>
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-family: "PingFang SC";
            font-size: 16px;
        }

        #box {
            height: 30px;
            width: 600px;
            padding: 0 10px;
            margin: 50px auto;
            border: 2px dashed green;
            background: lightgreen;
            overflow: hidden;
        }

        #box div {
            height: 22px;
            /*如果溢出，则显示滚动条*/
            /*overflow: auto;*/
            /*强制文字溢出不换行*/
            white-space: nowrap;
            margin: 2px auto;
            display: inline-block;
        }

        .stitle {
            color: #c81623;
            font-weight: bold;
        }
    </style>
</head>
<body>

    <div id="box">
        <div id="wrap">
            <div id="conBegin">
                <span class="stitle">名言警句：</span>只要下定决心克服恐惧，便几乎能克服任何恐惧。因为，请记住，除了在脑海中，恐惧无处藏身。——戴尔·卡耐基
            </div>
            <div id="conEnd">
                <span class="stitle">名言警句：</span>只要下定决心克服恐惧，便几乎能克服任何恐惧。因为，请记住，除了在脑海中，恐惧无处藏身。——戴尔·卡耐基
            </div>
        </div>
    </div>
    <!--为了解决滚动到底后调头是的闪烁，再复制一个，排列在其后，使其看上去像是连续的，和电影动画制作原理一样。-->
<script type="text/javascript">
    var box = document.getElementById("box");
    var wrap = document.getElementById("wrap");
    var conBegin = document.getElementById("conBegin");
    var timer = window.setInterval(function () {
        var target = conBegin.clientWidth;
        box.scrollLeft += 1;
        var cur = box.scrollLeft;
        if(cur >= target) {
            box.scrollLeft = 0;
        }
    }, 10)
</script>
</body>
</html>
```

----------

## 课时55：深入扩展-JS同步与异步编程

- JavaScript都是单线程的 -> JS就是个啥子，脑子一根筋，做着手头上的事情，没有完成前绝对不会去做下一件事件

- 同步：上一件事情没有完成，继续处理上一件事情，只有上一件事情完成了，才会做下一件事情(JS中大部分是同步)

- 异步
  - JavaScript中异步编程的四种情况：定时器都是异步编程、所有的事件绑定都是异步编程、Ajax读取数据也是异步的、回调函数也是异步的

```javascript
var n = 0
window.setTimeout(function () {
  n++
  console.log(n)
} ,1000)
console.log(n)
// 输出结果： 0，1  (中间有1000ms的等待再输出1)
//------------------------------
var n = 0
window.setTimeout(function () {
  n++
  console.log(n)
} ,0)
console.log(n)
// 输出结果： 0，1 
```

- 每个浏览器对于定时器的等待时间都有一个最小值：chrome:5~6ms, ie:10~13ms。如果设置的等待时间小于这个值，也不会起作用的，还是需要等到最小值的时间后才去执行定时器里的方法。尤其是写0也不是立即执行！

```javascript
var n = 0
window.setTimeout(function () {
  n++
  console.log(n)
}, 0)
console.log(n)
while (1) {
  n++
}
console.log(n)
// 这段代码会被while循环一致卡死，导致定时器没得时间允许方法，也导致最后一行代码没得执行
// 最后只输出 0
```

- 定时器设置的等待时间不一定是实际预期那下执行的时间，因为如果定时器之后还有别的一大堆代码要执行，则不管定时器定时的时间有没有到，都是不会去执行定时器的！ --> 单线程的完美体现

```javascript
var n = 0
window.setTimeout(function () {
  n += 2
  console.log(n)
}, 50)

window.setTimeout(function () {
  n += 5
  console.log(n)
}, 5)
console.log(n)
for (var i=0;i<1000000;i++) {}
console.log(n)
// 输出结果依次： 0 0 5 7
```

![task-queue.png-76.6kB][4]

----------

## 课时56：延迟加载思想和首屏延迟加载

> 延迟加载的作用：保证页面打开的速度

- 原理
  1. 对于首屏内容中的图片：首先给对应的区域一张默认图片站着位置(默认图片需要非常小，一般1~5kb以内)，当首屏内容都加载完毕以后(也可以预设一个延迟加载时间)，再开始加载真实图片
  2. 对于其它屏中的图片，也是给定一个默认的图片站位，当滚动条滚到对应区域时，就开始加载改区域的真实图片

- 关于语句的异步加载，开始只把前两屏的数据加载绑定出来，后面的数据不进行处理，当页面滚到对应区域时再开始从新请求数据然后绑定渲染数据
  
- DEMO实现步骤
  - 给img包一个容器div，样式里默认给img标签默认隐藏，并且给包img的容器div加一个默认占位图片 
  - js中先设一个定时器模拟延时加载，然后创建一个临时img标签，用这个临时img标签拿img.onload事件监听图片能正常加载事件，如果成功就赋值真实图片地址给img

```html
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>图片延迟加载</title>
    <style type="text/css">
        #box {
            width: 1000px;
            height: 410px;
            border: 2px solid lightgray;
            padding: 2px;
            margin: 20px auto;
            background: url("./img/tb_default.gif") no-repeat center #fefefe;
        }
        #box img {
            height: 100%;
            width: 100%;
            display: none;
        }
    </style>
<body>
<div id="box">
    <img src="" rscr="./img/yngf.jpg" alt="yngf">
</div>

<script type="text/javascript">
    console.log(document.images[0].attributes["rscr"].nodeValue);
    var timer = window.setTimeout(function () {
        var rsrc = document.images[0].getAttribute("rscr");
        // 创建img对象的普通方法
        // var timg = document.createElement("img")
        // 也可以直接用Image构造函数实例化一个对象
        var timg = new Image;
        timg.src = rsrc; // 复制目标图片url给临时图片对象
        // Image.onload 监听图片正常加载事件
        timg.onload = function () {
            document.images[0].style.display = "block";
            document.images[0].src = rsrc;
        };
    }, 1000)
</script>
</body>
</html>
```

----------

## 课时57：单张图片的延迟加载

![img-lazy-loading-base.png-54.3kB][5]

```javascript
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>图片延迟加载_plus</title>
    <style type="text/css">
        #box {
            width: 1000px;
            height: 410px;
            border: 2px solid lightgray;
            padding: 2px;
            margin: 1000px auto;
            background: url("./img/tb_default.gif") no-repeat center #fefefe;
        }
        #box img {
            height: 100%;
            width: 100%;
            display: none;
        }
    </style>
<body>
<div id="box">
    <img id="img" src="" rscr="./img/yngf.jpg" alt="yngf">
</div>
<script type="text/javascript" src="../utils.js"></script>
<script type="text/javascript">
    var box = document.getElementById("box");
    var img = document.getElementById("img");

    window.onscroll = function () {
        if (img.isLoad) return;
        var A = utils.offset(box).top + box.offsetHeight;
        var B = (document.documentElement.clientHeight || document.body.clientHeight) + (document.documentElement.scrollTop || document.body.scrollTop)
        if (A < B) {
            var timg = new Image;
            var rsrc = img.getAttribute("rscr");
            timg.src = rsrc;
            timg.onload = function () {
                img.src = img.getAttribute("rscr");
                img.style.display = 'block';
                img.isLoad = true;
            }
        }
    }
</script>
</body>
</html>
```

----------

## 课时58：多张图片的延迟加载实战

***实现步骤：***

 1. 远程加载数据 --> Ajax
    (1).创建xhr对象(兼容IE💪)
    (2).配置xhr对象(open方法第三个参数别写🤝)
    (3).监听xhr对象的状态变化并设置回调函数
    (4).发送xhr请求(null😘)
 2. 数据绑定 -> 把json数据转换对象后绑定到页面元素上，三种方法中选字符串拼接，绑定完记得来一起图片延迟加载函数
 3. 图片延迟加载
    (1).先写allImgLazyLoad函数，过滤出要延迟加载的图片
    (2).循环此图片是否已经加载过真实图片url，如果加载则跳过
    (3).如果没加载真实图片url，视为需要延迟加载图片对象
    (4).判断该图片容器offset距离和滚动条距离关系，该加载就启动图片加载函数
    (5).图片加载函数中设置图片属性，并记得加载fadeIn动画
 4. 图片渐入fadeIn动画
    (1).一定要把图片对象的栈地址当参数传入，因为异步坑人
    (2).设置durtion、target、interval、step、timer对象
    (3).启动定时器
    (4).在定时器中判断时，必须使用`window.getComputedStyle`封装的方法来判断当前元素的css样式属性，否则就坑一个跳吧😂
    (5).赋值样式属性值(+step)
    (6).**动画结束后清除定时器**
 5. `window.onscroll = allImglazyLoad`


```html
    <style type="text/css">
        * {
            margin: 0;
            padding: 0;
            font-size: 14px;
        }

        ul, li {
            /*去除ul和li默认样式(小圆点)*/
            list-style: none;
        }

        img {
            display: block;
            border: none;
        }

        /*移动端布局小技巧：最外层盒子是不设置宽和高的*/

        .news {
            padding: 10px;
        }

        .news li {
            /*设置li下级元素的父级参照物为li*/
            position: relative;
            height: 60px;
            padding: 10px 0;
            /*在每个li下面拿底边框加一个灰色分割线*/
            border-bottom: 1px dashed #9c9a9c;
        }

        /*.news li > div:nth-child(1)*/
        .news li > div:first-child {
            /*固定此div根据上级li为父级参照物来定位*/
            position: absolute;
            top: 10px;
            left: 0;
            width: 120px;
            height: 80px;
            background: url("./img/58/tb_default.gif") no-repeat center #fefefe;
        }

        .news li > div:first-child img {
            /*设置图片的宽高为父级盒子的匡和高*/
            height: 100%;
            width: 100%;
            display: none;
            opacity: 0;
        }

        .news li > div:last-child {
            height: 80px;
            margin-left: 125px;
        }

        .news li > div:last-child h2 {
            height: 20px;
            line-height: 20px;
            /*实现文字溢出后出现台阶*/
            overflow: hidden;
            /*文字超出的拆切部分以'...'代表*/
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        .news li > div:last-child p {
            height: 40px;
            line-height: 20px;
            font-size: 12px;
            color: #616161;
            overflow: hidden;
            /*文字超出的拆切部分以'...'代表*/
            text-overflow: ellipsis;
            white-space: pre-wrap;
        }
    </style>
    
<script>
  function allImglazyLoad() {
    var imgList = utils.listToArray(oul.getElementsByTagName('img'));
    var curImg = null;
    for (var i = 0, len = imgList.length; i < len; i++) {
      curImg = imgList[i];
      // 过滤图片还没加载的
      if (curImg.isLoad) {
        return
      }
      // A = 包图片的盒子外边框到body的距离 + 包图片盒子自身容器的高度
      // var A = utils.offset(curImg.parentNode).top + curImg.parentNode.offsetHeight
      // A = 包图片的盒子外边框到body的具体 + 包图片的自身容器一半的高度
      var A = utils.offset(curImg.parentNode).top + curImg.parentNode.offsetHeight / 2
      // B = 当前浏览器可视窗口的高度 + 滚动条卷去的高度
      var B = utils.win('clientHeight') + utils.win('scrollTop');
      if (A < B) {
        imgLoad(curImg);
        fadeIn(curImg);
      }
    }
  }

  function imgLoad(curImg) {
    //新建一个临时Image实例对象用于验证图片url是否有错
    var tempImg = new Image();
    tempImg.src = curImg.src = curImg.getAttribute('rsrc');
    tempImg.onload = function () {
      curImg.style.display = 'block';
      curImg.src = this.src; // 这里this就是调用主体tempImg
      tempImg = null;  // 清除无用栈内存
    };
    curImg.isload = true; // 设置图片的isload属性为true，以后检测是直接跳过该元素标签

    // 这里在使用onload加载时，是一个异步时间，他找不到curImg了
    // 咋个子证明呢？ 它里面的i已经是30~~~~~~~~~~！！！！！！
    // 这里异步咋理解呢？就是说，引擎不等图片是否给加载完成，是直接你小子是异步，后面好了你再更我说，老子先往下面执行着，我好了我会告诉你，你再执行。
    // 再说清楚点吧，也就是说curImg里的i已经是最后一个index了，所以他永远指向最后一个元素
    // 这种异步，一个图片还好整，一堆图片它就不等你加载完再处理了
    // 为了解决异步问题，把处理函数单独写成一个，传参时直接传内存地址即可解决问题
    //var timg = new Image
    //timg.src = curImg.getAttribute('rsrc')
    //console.log(timg.src)
    //timg.onload = function () {
    //  console.dir(curImg)
    //  console.log("图片地址没问题")
    //  curImg.src = curImg.getAttribute('rsrc')
    //  curImg.isLoad = true
    //  curImg.style.display = 'block'
  }

  function fadeIn(curImg) {
    var duration = 1000; // 动画的持续时间
    var target = 1; // 动画完成时的目标数值
    var interval = 10; // 动画每隔多少毫米执行一次
    var step = (target / duration) * interval;  // 每次执行定时器需要加上的步长
    var timer = window.setInterval(function () {
      if (curOpacity >= target) { // curOpacity为预解释声明，第一次定时器执行时为null
        window.clearInterval(timer);
        return
      }
      var curOpacity = utils.css(curImg, 'opacity');
      curOpacity += step;
      curImg.style.opacity = curOpacity;
      curImg.style.filter = 'alpha(opacity=' + curOpacity * 100 + ')'
    }, interval)
  }
</script>
    
```

- 细节记录：
  - webstorm中html里，`meta:vp`+`tab`快速移动端布局头
  - 移动端布局小技巧：最外层盒子是不设置宽和高的

----------

## 课时59：内置的dom操作属性和方法

- 获取页面元素的方法
  - document.getElementById()
  - context.getElementsByTagName("tagname") -> 把指定容器中子子孙孙辈的所有标签名为tabname的节点都获取到
  - context.getElementsByClassName("classname") -> 在ie6~8下不兼容
  - doucment.getElementsByName("name") -> 在IE浏览器中只对表单元素的name起作用
  - document.body -> 获取body对象
  - document.documentElement -> 获取整个html对象
  - context.querySelector/context.querySelectAll -> 在ie6~8下不兼容，且通过选择器获取到的节点集合不存在**dom mapping**！！

- 描述节点和节点之间关系的属性(在标准浏览器中会把空格和换行当做文本节点处理)
  - childNodes -> 获取所有子子孙孙节点
  - children   -> 获取所有子元素节点 (ie6~8不兼容)
  - parnetNode -> 获取父节点
  - previousSibling/previousElementSibling -> 获取上一个哥哥节点/哥哥元素节点【注：所有和Element有关的属性在ie6~8不兼容】
  - nextSibling/nextElementSibling -> 获取下一个弟弟节点/弟弟元素节点【同上】
  - lastChild/lastElementChild  -> 获取最后一个子节点/子元素节点【同上】
  - firstChild/firstElementChild  -> 获取第一个子节点/子元素节点【同上】

- DOM的增删改
  - createElement
  - document.createDocumentFragment
  - appendChild
  - insertBefore
  - cloneNode(true/false): true对应克隆整个元素，false对应只克隆标签
  - replaceChild
  - removeChild
  - [get/set/remove]Attribute

- DOM盒子模型(常用的13个)
  -  client系列
  -  offset系列
  -  scroll系列

----------

## 课时60：获取所有的元素子节点

> 因为`children`属性在ie6~8中不兼容，那就自己实现一个呗！

> 二次循环，担心数组的塌陷问题。如果在循环中操作的数组当前对象长度会变化，注意补偿。

```javascript
function children (curEle, tagName) {
    var arr = [];
    var flag = /MSIE [6|7|8]/.test(window.navigator.userAgent);
    if (flag) {
        var cnodes = utils.listToArray(curEle.childNodes);
        cnodes.forEach(function (item) {
            // 先亲子鉴定！！！再鉴定nodeType是不是元素节点，元素节点为1
            if (item.parentNode === curEle && item.nodeType === 1) {
                arr[arr.length] = item;
            }
        })
    } else {
        arr = utils.listToArray(curEle.children);
    }
    if (tagName !== undefined) {
        for (var j = 0; j < arr.length; j++) {
            // 循环找tabName不匹配的元素
            if(arr[j].tagName.toLowerCase() !== tagName.toLowerCase()) {
                // 找到不匹配的元素就删除
                arr.splice(j, 1);
                // 恢复索引, 若恢复索引会出现数组塌陷问题
                j--;
            }
        }
    }
    return arr;
}
```

## 课时61：课时61：深入扩展-单例模式的小技巧

```javascript
//单利模式小技巧
// 这里处理可以先在不清除内存的私有作用域做一些预处理
var utils = (function () { 
    // 【惰性加载】
    // 原理：如果下面的代码需要使用一些代码实现判断，则我们把代码的实现放在外层，在里层使用时，只需要引用即可，不需要多次代码去实现。
    var flag = /^\d+$/
    ... 
    return { ... }    
})()
```

----------


## 课时62： 获取元素

- prev：获取元素的哥哥元素节点

```javascript
function prev (curEle) {
  var bro = curEle.previousSibling  // 获取元素的哥哥节点
  while (bro) {
    if (bro.nodeType === 1) { //判断是不是元素
      return bro 
    }
    bro = bro.previousSibling
  }
  return null
}
```

- next：获取元素的弟弟元素元素

```javascript
function next (curEle) {
  var bro = curEle.nextSibling  // 获取元素的哥哥节点
  while (bro) {
    if (bro.nodeType === 1) { //判断是不是元素
      return bro 
    }
    bro = bro.nextSibling
  }
  return null
}
```

- prevAll：获取元素的所有哥哥元素

```javascript
function prevAll () {
  var arr = []
  var bro = this.prev(curEle)
  while(bro !== null) {
    arr.unshift = bro  // 存放哥哥元素时最大的哥哥排在数组最前面
    bro = this.prev(bro)
  }
  return arr
}
```

- nextAll：获取元素的所有弟弟元素

```javascript
function nextAll (curEle) {
  var arr = []
  var bro = this.next(curEle)
  while(bro !== null) {
    arr.push(bro)  // 存放哥哥元素时最大的哥哥排在数组最前面
    bro = this.next(bro)
  }
  return arr
}
```

- sibling：获取元素的一个哥哥和一个弟弟元素

```javascript
function sibling (curEle) {
  var arr = []
  arr.push(this.prev(curEle)) //如果有哥哥，没有就null
  arr.push(this.next(curEle)) //如果有弟弟，没有就null
  return arr
}
```

- siblings：获取元素的所有兄弟元素

```javascript
function siblings (curEle) {
  return this.prevAll(curEle).concat(this.nextAll(curEle))
}
```

- index：获取元素在同辈中的索引

```javascript
function index (curEle) {
  return this.prevAll(curEle).length
}

```

- firstChild：获取元素的第一个子元素

```javascript
function firstChild (curEle) {
  var ec = this.children(curEle)
  return ec[0] ? ec[0] : null
}
```

- lastChild：获取元素的最后一个子元素

```javascript
function lastChild (curEle) {
  var ec = this.children(curEle)
  return ec[ec.length - 1] ? ec[ec.length - 1] : null
}
```

----------

## 课时63：向容器中追加新元素的方法

- append：内置方法，向指定容器的末尾追加元素

- prepend：向指定容器的开头追加元素
  - 原理 -> 0. 把新元素添加到容器中的第一个子元素节点前面 
  - -> 1. 先查找容器中的第一个子元素节点
  - -> 2. 如果存在，就将要追加的元素插入容器第一个元素的前面
  - -> 3. 如果不存在，就将要追加的元素直接插入末尾即可
  

```javascript
function prepend (newEle, container) {
    var fir = this.firstChild(container);
    if (fir) { // 如果容器中有节点
      container.insertBefore(newEle, fir)
      return
    }
    container.appendChild(fir)
}
```

- insertBefore：类似内置方法，把新元素追加到指定元素的前面 

```javascript
function insertBefore (newEle, oldEle) {
    oldEle.parentNode.insertBefore(newEle, oldEle)
}
```

- insertAfter：把新元素追加到指定元素的后面
  - 原理 -> 0. 把新元素追加到指定元素弟弟元素的前面 
  - -> 1. 如果弟弟元素存在，就获取父节点后用insertBefore()方法将新元素插入到弟弟元素的前面即可
  - -> 2. 如果弟弟元素不存在，就直接获取父节点后用appendChild方法将新元素插入末尾即可

```javascript
function insertAfter (newEle, oldEle) {
    var bro = this.next(oldEle)
    if (bro) {  // 如果弟弟元素存在，就把新元素追加到弟弟元素的前面
      oldEle.parentNode.insertBefore(newEle, bro)
    }
    // 如果指定元素已经是最末尾元素，就直接获取父节点后appendChild即可
    oldEle.parentNode.appendChild(newEle)
}
```

----------

## 课时64：操作元素的样式类

- hasClass：判断元素style属性是否存在某类名

```javascript
function hasClass(curEle, className) {
    // 分析需求：
    // 情况1 -> "size" === /^size +/ , 当判断的类名在字符串首位时，就是以某某开头后面可以跟一到多个空格
    // 情况2 -> "center" === / +center +/ ，当判断的类名在字符串中间时，就是以一到多空格开头和结尾中间就是类名
    // 情况3 -> "className" === / +border^/
    // 从以上三种情况分析可得：/(^| +)className( +|&)/
    // 别忘了再给className传入参数左右两边取空格
    var reg = new RegExp('(^| +)?' + className + '( +|&)?')
    return reg.test(curEle.className)
}
```

- addClass：为指定元素添加css类名

```javascript
function addClass(curEle, className) {
    // 首先去除参数字符串左右两边的多余空格，然后一定要用正则的split分割
    var classAry = className.trim().split(/ +/g);
    classAry.forEach(function (item) {
        if(!hasClass(curEle,item)) {
            curEle.className += ' ' + item;
        }
    })
}
```

- removeClass：为元素删除某些css类名

```javascript
  // 为元素删除某些css类名
  function removeClass(curEle, className) {
    // 首先去除参数字符串左右两边的多余空格，然后一定要用正则的split分割
    var classAry = className.trim().split(/ +/g);
    classAry.forEach(function (curClaName) {
      if (hasClass(curEle, curClaName)) { //如果存在则移除
        // 设置正则匹配以className开头或者一到多个空格开头或结尾
        var reg = new RegExp("(?:^| +)" + curClaName + "(?: +|$)", 'g'); // 修复正则，不需要的不捕获！
        curEle.className = curEle.className.replace(reg, " ");
      }
    })
  }
```

----------

## 课时65：getElementsByClassName的实现与兼容处理

- 实现步骤：
  - 先验证传入className是否存在和是否为字符串，否的话就返回空数组
  - 验证传入容器参数是否存在，不存在默认设为document
  - 将传入的类名字符串先去两边的空格，再拿split+正则分割成数组
  - 使用`.getElementsByTagName('*')`获取该容器内的所有标签元素
  - 外循环循环容器元素类数据，内循环循环classAry类名数组
  - 使用假设验证，在内循环分别验证该元素是不是不存在该类名，不存在直接赋值isValid为false后中断循环
  - 如果传入验证结果通过，将该元素加入结果数组
  - 返回结果数组

```javascript
// 实现getElementsByClassName
function getElementsByClassName (className, container) {
  // 如果没传className或者不是字符串则返回空数组
  if(!className && (typeof className !== "string")) {
    return [];
  }
  // 如果没传container容器则默认设为document
  if (!container) {
    container = document;
  }
  var res = [];
  // 使用所有浏览器都兼容的getElementsByTagName方法加通配符获取所有节点
  var elemtnts = container.getElementsByTagName('*');
  // 使用正则分割传递进来的类名字符串成数组
  var classAry = className.trim().split(/ +/g);
  for (var i =0; i<elemtnts.length; i++) // 循环容器内的元素节点
  { // 假设结果验证为true
    var isValid = true;
    var curEle = elemtnts[i];
    for (var j=0, len=classAry.length; j<len; j++) {
      // 判断当前元素节点是否有该类名，没有就直接中断内循环设置isValid为false
      if(!hasClass(curEle, classAry[j])) {
        isValid = false;
        break;
      }
    }
    if (isValid) { // 只有当验证通过才将元素加入结果数组
      res.push(elemtnts[i]);
    }
  }
  return res; // 返回结果数组
}
```

----------

## 课时66：设置元素的样式值setCss

> **在JavaScript中给元素设置样式的属性值，我们只能通过`curEle.style[attr] = value`的方式设置当前元素的行*内样式***

- 实现步骤：

  1. 特殊处理兼容IE的属性，如opacity,float.....，处理完直接`return`
  2. 写匹配正则，以width,top...等或者borderTop,paddingLeft...开头和结尾
  3. 匹配上+是一个有效数字就加默认单位px
  4. 否者直接赋值给行内样式

```javascript
function setCss (curEle, attr, value) {
  //处理特殊样式设置
  //特殊1：opacity  (兼容IE6~8)
  if (attr === "opacity") {
    curEle.style.opacity = value;
    curEle.style.filter = 'alpha(opacity='+ value*100 +')';
    return;
  }
  // 特殊2：float  (兼容IE6~8)
  if (attr === "float") {
    curEle.style['cssFloat'] = value;
    curEle.style['styleFloat'] = value;
    return;
  }
  var reg = /^(width|height|top|bottom|left|right|((border|padding)(Top|Bottom|Left|Right)?))$/;
  if(reg.test(attr)) {
    if (!isNaN(value)) { // 判断是否是一个有效数字
      // 如果是一个有效数字，证明传进来的value是没有单位的，则需要我们手工补默认单位px
      value += 'px';
    }
  }
  // 实在是匹配不上了就直接赋值
  curEle.style[attr] = value;
}
```

----------

## 课时67：批量设置元素的样式值

- 实现步骤
  - 判断传入options必须为对象，不是object类则直接返回
  - for...in循环options
  - 判断是否为options的私有(自身)属性

```javascript
function setGroupCss (curEle, options) {
  options = options || 0; // 如果为undefined则设置为0
  if (Object.prototype.toString.call(options) !== '[object Object]') {
    return;
  }
  // 这里for...in循环时遍历公有+私有
  for (var key in options) {
    // 则必须过滤只循环私有属性
    if(options.hasOwnProperty(key)) {
      setCss(curEle, key, options[key])
    }
  }
}
```

----------

## 课时68：获取、设置、批量设置元素

```javascript
  function css (curEle) {
    // arguments所包含所有传入参数！
    var argSec = arguments[1];
    var argThd = arguments[2];
    if (typeof argSec === 'string') {
      // 如果第二个参数为字符串且第三个参数没传就证明只是获取css属性的值
      if (!argThd) {
        return getComputedCss(curEle, argSec);
      }
      // 否则就是单个设置css属性的值
      setCss(curEle,argSec, argThd)
    }
    argSec = argSec || 0; // 如果是undefined就赋值0
    if(Object.prototype.toString.call(argSec) === '[object Object]') {
      setGroupCss(curEle, argSec)
    }
  }
```

- Utils优化步骤：
  - 第1步：私有化getComputedCss、setCss、setGroupCss，在css中直接调用该方法，不能使用this关键字；
  - 第2步：优化css中调用方法，改用call和apply方法，替换目标方法中`this`为curEle；改后getComputedCss、setCss、setGroupCss三个方法不用再传递curEle元素，因为`this`已经指向此目标元素，所有替换三个方法中所有curEle为`this`;
  - 第3步：修复setGroupCss方法中调用setCss.call。

```javascript
  function css(curEle) {
    // arguments所包含所有传入参数！
    var argSec = arguments[1];
    var argThd = arguments[2];
    if (typeof argSec === 'string') {
      // 如果第二个参数为字符串且第三个参数没传就证明只是获取css属性的值
      // 这里不能简单取反，因为当argthd为0时，取反就是true，肯定不对
      if (typeof argThd === 'undefined') {
        return getComputedCss.call(curEle, argSec);
      }
      var argList = this.listToArray(arguments).splice(1);
      // 否则就是单个设置css属性的值
      setCss.apply(curEle, argList)
    }
    argSec = argSec || 0; // 如果是undefined就赋值0
    if (Object.prototype.toString.call(argSec) === '[object Object]') {
      setGroupCss.call(curEle, argSec)
    }
  }
```
  
----------

## 课时69：css方法的一个bug解决

```javascript
// 当css给的第三个参数为0时，取反就是true，有问题！
utils.css('box', 'width', 0)
// if (typeof argThd === 'undefined')
```

----------

## 课时70：选项卡插件的封装

- 关于浮动的产生：由于没给最外层的盒子box设置高度，到时盒子容器中前三个li设置了向左浮动float后，则导致下面的弟弟元素们往上"填"，这就是哥哥元素的浮动对弟弟元素的影响。

- ***清除浮动的方法***：
  1 在弟弟元素上设置css`clear: both;`：清除兄弟元素的浮动对哥们元素的影响
  2 在ul里设置css`overflow: hidden;`：清除子元素的浮动对父级元素的影响
  3 在浮动的元素末尾加一个after伪类，伪类里设置css`display:block; content:""; clear: both;`：在浮动元素(此例为ul加伪类)最后加一个块级元素，填满此“行”，然后内容设置为空，最后设置clear清除兄弟元素浮动对伪类的影响，这样伪类后的元素不会再受到浮动影响

- 选项卡小样式设计：看下图，页卡选项好土，不和谐，得改。

![tabList01.png-11.8kB][6]

- 实现原理，让选中的选项卡融入的选项内容中去😏，实质就是移动li的位置，向下移动点，然后把选中li的底边框颜色故意设置成选项内容的颜色，然后移动一个像素下来，刚好用li的底边框颜色覆盖掉选项内容的边框颜色，视觉上让人们感觉是融入了，但其实只是两者边框覆盖而已。
- 实现步骤：
  - 先让ul里的li(们)要相对定位，因为我们要移动它的相对位置嘛。所以我们让ul的`position`设置为相对定位，即让ul的父级参照物设置为容器盒子box。
  - 设置ul的父级参照物后就可以把ul相对于容器盒子box的顶部top往下移动一个像素，这样li的边框刚好覆盖到选项内容div的边框，再设置选中li得底边框颜色为选项卡内容的背景颜色。

![tabList02.png-11.8kB][7]

- 在onclick的监听函数中，系统默认仅传递一个eventTarget对象为参数进函数里，然后此监听函数中的this就是被点击的元素li！

- 升级tabChage选项卡点击事件的hanlder处理函数，解耦！
  - hanlder函数不接受任何参数
  - handler函数不引用外部任何变量

```javascript
// 原来的代码 low~~~
var box = document.getElementById('box'),
    oLis = box.firstElementChild.getElementsByTagName('li'),
    oDivs = utils.children(box, 'div'); //必须考虑只要box的子元素节点！

function chageTab (n) {
  for (var i=0, len=oLis.length; i < len; i++) {
    utils.removeClass(oLis[i],'selected');
    utils.removeClass(oDivs[i],'selected');
  }
  utils.addClass(oLis[n], 'selected');
  utils.addClass(oDivs[n], 'selected');
}

for (var i=0, len=oLis.length; i < len; i++) {
  oLis[i].onclick = function (eventTarget) {
    var num = utils.index(this); // 获取点击的那个li到底在同辈中排行老几？
    chageTab(num);
  }
}
///////////////////////////////////////////////
// 新的实现代码，安全解耦！！！
for (var i=0, len=oLis.length; i < len; i++) {
  oLis[i].onclick = tabClickHandler;
}

function tabClickHandler () {
  var self = this;
  // 获取所点击元素li在同辈中排行老几！
  var index = utils.index(self);
  // 获取点击li的所有兄弟元素节点，然后循环删除selected样式类名
  utils.siblings(self).forEach(function (cur) {
    utils.removeClass(cur, 'selected');
  });
  // 给点击li添加选中样式类名
  utils.addClass(self, 'selected');
  // 获取与点击li在同辈排行序号相同的div元素
  var curDiv = utils.nextAll(this.parentNode)[index];
  // 循环这个div的所有兄弟元素并删除选中样式
  utils.siblings(curDiv).forEach(function (cur) {
    utils.removeClass(cur, 'selected');
  });
  // 给对应div添加选中样式
  utils.addClass(curDiv, 'selected');
  self = null;
  index = null;
}
```

- 选项卡实现原理：
  1. 通过this获取所点击元素li在同辈中排行index
  2. 获取点击li的所有兄弟元素节点，然后循环删除selected样式类名
  3. 给点击li添加选中样式类名
  4. 获取与点击li在同辈排行序号index相同的div元素
  5. 循环这个div的所有兄弟元素并删除选中样式
  6. 给对应div添加选中样式

- ***封装选项卡***

- 方法一：立即执行函数
  - 创建tab.js文件
  - 在文件内创建initTab方法，获取需要将容器变为选项卡的容器dom对象
  - 在闭包的最后用window属性赋值方式把initTab方法引出去

```javascript
~function () {
  function initTab (ele) {
    var ul = utils.firstChild(ele);
    utils.children(ul, 'li').forEach(function (cur) {
      cur.onclick = tabClickHandler
    })
  }

  function tabClickHandler () {
    var self = this;
    // 获取所点击元素li在同辈中排行老几！
    var index = utils.index(self);
    // 获取点击li的所有兄弟元素节点，然后循环删除selected样式类名
    clearSiblingsClassName(self, 'selected')
    // 给点击li添加选中样式类名
    utils.addClass(self, 'selected');
    // 获取与点击li在同辈排行序号相同的div元素
    var curDiv = utils.nextAll(this.parentNode)[index];
    // 循环这个div的所有兄弟元素并删除选中样式
    clearSiblingsClassName(curDiv, 'selected')
    // 给对应div添加选中样式
    utils.addClass(curDiv, 'selected');
    self = null;
    index = null;
  }
  
  function clearSiblingsClassName (ele, className) {
    utils.siblings(ele).forEach(function (item) {
      utils.removeClass(item, className)
    })
  }
  
  window.initTab = initTab
}()
```

- 关于eventTarget与window.event

```javascript
box.onclick = function tabClickHandler (event) {
    console.log(event === window.event) // true
}
```

- tab.js再次升级，初始化时增加了默认选中项

```javascript
  function setDefaultItem (container, defaultIndex, className) {
    if (container === undefined) return null;
    defaultIndex = defaultIndex || 0;
    className = className || "selected";
    // 获取ul元素后再获取它的所有子元素li
    var oLis = utils.children(utils.firstChild(container), 'li');
    var oDivs = utils.children(container, 'div');
    for (var i=0, len=oLis.length; i<len; i++) {
      if (i === defaultIndex) {
        utils.addClass(oLis[i], className);
        utils.addClass(oDivs[i], className);
      } else {
        utils.removeClass(oLis[i], className);
        utils.removeClass(oDivs[i], className);
      }
    }
  }
```

- tab.js再次升级，改为事件委托方法绑定。将原来li上的onclick移到父元素ul上，在调用handler时只需要将里面this改成e.target即可！

```javascript
  function initTab (container, defaultIndex) {
    var ul = utils.firstChild(container);
    setDefaultItem(container, defaultIndex);
    ul.onclick = function (e) {
      // 获取event的保险写法，有些浏览器如果参数e没赋值，会在window.event上有这次点击的event对象
      // 如果实参e在函数参数上没获取到，就去window.event上获取
      e = e || window.event;
      // 如果e的target为undefined则用e.srcElement赋值
      e.target = e.target || e.srcElement;
      // 如果所点击的是ul下的li元素
      if(e.target.tagName.toLowerCase() === 'li') {
        // 还是调用原来的方法，只是改变了this
        tabClickHandler.call(e.target);
      }
    }
  }
```

- **tab.js再次升级，改为以构造函数方式封装。**
  - 首先还是在闭包内开一个大写Tab函数；
  - 然后修改其原型
  - 原型修改第一步一定先设置`constructor`
  - 然后设置init函数，函数里接受容器参数和默认选用序号
  - 本该应该在init设置一些类的实例属性，如`oLis`、`oDivs`等。但这些公共属性也就在类的某一个方法中用一次，这个到底该加到类中吗？我觉得没必要了，还是保持方法的低耦合。

```javascript
  function Tab () {

  }

  Tab.prototype = {
    constructor: Tab,
    // 初始化
    init: initTab
  }
```

- 总结正常情况下使用构造函数(面向对象方式)创建一个插件步骤：
  1. 立即执行函数里大写字母开头函数来一个，没错，就是传说中的***构造函数***！
  2. 重新为这个构造函数的原型赋值一个对象，这个对象第一步先要让`constructor`属性执行这个构造函数！
  3. 正常情况先来一个init属性-函数，接收参数，设置类实例的共有属性...
  4. 设置一些处理函数
  5. 最后window.Cons返回即可
  

  [1]: http://static.zybuluo.com/szy0syz/yrvs2poihx4r4qdmgqjjigy4/image.png
  [2]: http://static.zybuluo.com/szy0syz/v850efctc8h7txof2v5ak8cz/image.png
  [3]: http://static.zybuluo.com/szy0syz/09p3oh487y8k60tj330xdi03/HTMLElement_offsetLeft_plus.png
  [4]: http://static.zybuluo.com/szy0syz/954d247dzc5iwwheeel2g57m/task-queue.png
  [5]: http://static.zybuluo.com/szy0syz/mh6q7kn309897ykvxqh2cd45/img-lazy-loading-base.png
  [6]: http://static.zybuluo.com/szy0syz/z2s7witk04wtx5bv5fp0tbrk/tabList01.png
  [7]: http://static.zybuluo.com/szy0syz/yhejllgazy5zodwpv752sgek/tabList02.png
