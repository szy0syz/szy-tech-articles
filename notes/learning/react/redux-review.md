# redux复习之路

## 基本理念

### Redux的设计思想

1. Web 应用是一个状态机，视图与状态是一一对应的。
2. 所有的状态，保存在一个对象里面。

### Redux的三大原则

1. **单一数据源**。整个应用的 state 被储存在一棵 object tree 中，并且这个 object tree 只存在于唯一一个 store 中。

    这让同构应用开发变得非常容易。来自服务端的 state 可以在无需编写更多代码的情况下被序列化并注入到客户端中。由于是单一的 state tree ，调试也变得非常容易。在开发中，你可以把应用的 state 保存在本地，从而加快开发速度。此外，受益于单一的 state tree ，以前难以实现的如“撤销/重做”这类功能也变得轻而易举。

2. **State是只读的**。唯一改变 state 的方法就是触发 action，action 是一个用于描述已发生事件的普通对象。(action没权改state，只是挂着payload和事件名找reducer帮忙)

    这样确保了视图和网络请求都不能直接修改 state，相反它们只能表达想要修改的意图。因为所有的修改都被集中化处理，且严格按照一个接一个的顺序执行，因此不用担心竞态条件（race condition）的出现。 Action 就是普通对象而已，因此它们可以被日志打印、序列化、储存、后期调试或测试时回放出来。

3. **使用纯函数来执行修改**。为了描述 action 如何改变 state tree ，你需要编写 reducers。

    Reducer 只是一些纯函数，它接收先前的 state 和 action，并返回新的 state。刚开始你可以只有一个 reducer，随着应用变大，你可以把它拆成多个小的 reducers，分别独立地操作 state tree 的不同部分，因为 reducer 只是函数，你可以控制它们被调用的顺序，传入附加数据，甚至编写可复用的 reducer 来处理一些通用任务，如分页器。

## Redux使用场景

    多交互、多数据源

从业务角度来看：

* 用户的使用方式复杂
* 不同身份的用户有不同的使用方式(比如普通用户和管理员)
* 多个用户之间可以协作
* 与服务器大量交互，或者使用了WebSocket
* View要从多个来源获取数据

从组件角度来看：

* 某个组件的状态需要共享
* 某个状态需要在任何地方都能拿到
* 一个组件需要改变全局状态
* 一个组件需要改变另一个组件的状态

## 基本概念

### Store

Store就是保存数据的地方，你可以把它看成一个容器。整个应用只有一个Store。

Redux提供CreateSotre这个函数，用来生成Store。

### State

Store 对象包含所有数据。如果想得到某个时点的数据，就要对Store生成快照。这种时点的数据集合，就叫做State。当前时刻的State，可以用过store.getState()拿到。

Redux 规定， 一个 State 对应一个 View。只要 State 相同，View 就相同。你知道 State，就知道 View 是什么样，反之亦然。